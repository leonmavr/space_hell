<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Void Hunter</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #050505;
            color: #fff;
            font-family: 'Courier New', Courier, monospace;
            user-select: none;
        }

        #gameCanvas {
            display: block;
            margin: 0 auto;
            max-width: 1200px;
        }

        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
            text-shadow: 0 0 5px #0ff;
            z-index: 5;
        }

        .hud-text {
            font-size: 20px;
            margin-bottom: 5px;
            color: #0ff;
            font-weight: bold;
        }

        .status-text {
            font-size: 14px;
            color: #ff0;
            margin-top: 2px;
        }

        /* Bar Containers */
        .bar-container {
            width: 200px;
            height: 10px;
            border: 2px solid #555;
            margin-top: 5px;
            box-shadow: 0 0 5px #000;
            border-radius: 4px;
            position: relative;
            background: #000;
            margin-bottom: 5px;
        }

        #health-bar-container { border-color: #0ff; box-shadow: 0 0 10px #0ff; }
        #ultimate-bar-container { border-color: #d0f; box-shadow: 0 0 10px #d0f; }

        /* Fills */
        #health-fill {
            height: 100%;
            background-color: #0ff;
            width: 100%;
            box-shadow: 0 0 10px #0ff;
            transition: width 0.2s;
        }

        #armor-fill {
            position: absolute;
            top: 0; left: 0; height: 100%;
            background-color: #ff0;
            width: 0%;
            box-shadow: 0 0 10px #ff0;
            transition: width 0.2s;
            opacity: 0.7;
        }

        #ultimate-fill {
            height: 100%;
            background-color: #d0f;
            width: 0%;
            box-shadow: 0 0 10px #d0f;
            transition: width 0.1s linear;
        }
        
        #ultimate-text {
            position: absolute;
            top: -18px;
            left: 0;
            font-size: 12px;
            color: #d0f;
            font-weight: bold;
        }

        #game-over-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            display: none;
            z-index: 10;
        }

        /* --- MENU STYLES --- */
        #main-menu {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(5, 5, 5, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
        }

        .menu-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px 50px;
            margin-bottom: 40px;
            align-items: center;
        }

        .menu-label {
            text-align: right;
            font-size: 30px;
            color: #0ff;
            text-shadow: 0 0 10px #0ff;
            font-weight: bold;
        }

        .menu-control {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 120px;
        }

        .value-box {
            width: 100%;
            padding: 10px 0;
            border: 2px solid #f0f;
            background: rgba(20, 0, 20, 0.5);
            color: #fff;
            text-align: center;
            font-size: 24px;
            font-weight: bold;
            box-shadow: 0 0 10px #f0f, inset 0 0 10px #f0f;
            text-shadow: 0 0 5px #fff;
            margin: 5px 0;
        }

        .arrow-btn {
            color: #0f0;
            font-size: 20px;
            cursor: pointer;
            text-shadow: 0 0 5px #0f0;
            transition: transform 0.1s;
        }
        .arrow-btn:hover { transform: scale(1.2); color: #fff; }
        .arrow-btn:active { transform: scale(0.9); }

        .disabled-opt { opacity: 0.3; pointer-events: none; filter: grayscale(100%); }

        h1 {
            font-size: 60px;
            margin: 0 0 40px 0;
            color: #f0f;
            text-transform: uppercase;
            text-shadow: 0 0 20px #f0f, 0 0 40px #f0f;
            letter-spacing: 5px;
        }

        .btn {
            background: transparent;
            border: 2px solid #0f0;
            color: #0f0;
            padding: 15px 40px;
            font-family: 'Courier New', Courier, monospace;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            text-transform: uppercase;
            box-shadow: 0 0 15px #0f0, inset 0 0 10px #0f0;
            text-shadow: 0 0 5px #0f0;
            transition: all 0.2s ease;
            pointer-events: auto;
        }

        .btn:hover {
            background: #0f0;
            color: #000;
            box-shadow: 0 0 30px #0f0, inset 0 0 20px #0f0;
        }

        .controls-hint {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.5);
            font-size: 14px;
            pointer-events: none;
            width: 100%;
            text-align: center;
        }

        .floating-text {
            position: absolute;
            font-weight: bold;
            pointer-events: none;
            animation: floatUp 1s ease-out forwards;
            text-shadow: 0 0 5px #000;
        }

        .menu-input-row {
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 10px;
            width: 100%;
        }

        .menu-field-label {
            font-size: 14px;
            color: #0ff;
            text-shadow: 0 0 5px #0ff;
            white-space: nowrap;
        }

        .menu-input {
            background: rgba(10, 10, 10, 0.9);
            border: 2px solid #f0f;
            color: #fff;
            font-family: 'Courier New', Courier, monospace;
            font-size: 18px;
            padding: 4px 6px;
            width: 80px;
            box-shadow: 0 0 10px #f0f;
        }

        .menu-input.password {
            width: 120px;
        }

        @keyframes floatUp {
            0% { transform: translateY(0); opacity: 1; }
            100% { transform: translateY(-50px); opacity: 0; }
        }
    </style>
</head>
<body>

    <!-- MAIN MENU -->
    <div id="main-menu">
        <h1>SPACE HELL</h1>
        
        <div class="menu-grid">
            <!-- Sound -->
            <div class="menu-label">SOUND</div>
            <div class="menu-control">
                <div class="arrow-btn" onclick="updateSetting('sound', 1)">▲</div>
                <div class="value-box" id="val-sound">ON</div>
                <div class="arrow-btn" onclick="updateSetting('sound', -1)">▼</div>
            </div>

            <!-- World -->
            <div class="menu-label">WORLD</div>
            <div class="menu-control">
                <div class="arrow-btn" onclick="updateSetting('world', 1)">▲</div>
                <div class="value-box" id="val-world">1</div>
                <div class="arrow-btn" onclick="updateSetting('world', -1)">▼</div>
            </div>

            <!-- Difficulty -->
            <div class="menu-label">DIFFICULTY</div>
            <div class="menu-control">
                <div class="arrow-btn" onclick="updateSetting('difficulty', 1)">▲</div>
                <div class="value-box" id="val-difficulty">EASY</div>
                <div class="arrow-btn" onclick="updateSetting('difficulty', -1)">▼</div>
            </div>

            <!-- Wave / Password (Debug) -->
            <div class="menu-label">WAVE</div>
            <div class="menu-control">
                <div class="menu-input-row">
                    <span class="menu-field-label">WAVE</span>
                    <input id="wave-input" class="menu-input" type="number" min="1" max="999" />
                    <span class="menu-field-label">PASSWORD</span>
                    <input id="wave-password" class="menu-input password" type="password" maxlength="16" />
                </div>
            </div>
        </div>

        <button class="btn" onclick="startGameFromMenu()">LAUNCH!</button>
    </div>

    <!-- GAME UI -->
    <div id="ui-layer" style="display:none;">
        <div class="hud-text" id="score-display">SCORE: 0</div>
        <div class="hud-text" id="wave-display">WAVE: 1</div>
        <div class="hud-text" id="lives-display" style="color: #f00;">LIVES: 3</div>
        
        <div id="health-bar-container" class="bar-container">
            <div id="health-fill"></div>
            <div id="armor-fill"></div>
        </div>

        <div style="position: relative; margin-top: 31px;">
            <div id="ultimate-text">ULTIMATE (SHIFT)</div>
            <div id="ultimate-bar-container" class="bar-container">
                <div id="ultimate-fill"></div>
            </div>
        </div>

        <div id="powerup-status" class="status-text"></div>
        <!-- Container for floating texts -->
        <div id="floating-text-layer" style="position: absolute; top:0; left:0; width:100%; height:100%; pointer-events:none;"></div>
    </div>

    <div id="game-over-screen">
        <h1>SYSTEM FAILURE</h1>
        <div class="hud-text" id="final-score" style="margin-bottom: 30px; font-size: 30px; color: white;">SCORE: 0</div>
        <button class="btn" onclick="returnToMenu()">MAIN MENU</button>
    </div>

    <div class="controls-hint" id="game-controls-hint" style="display:none;">
        [W] THRUST &nbsp; [A/D] ROTATE &nbsp; [SPACE] SHOOT &nbsp; [SHIFT] ULTIMATE LASER &nbsp; [F] AUTOFIRE &nbsp; [P] PAUSE
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        // --- Configuration & Constants ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        const difficulties = ['EASY', 'MEDIUM', 'HARD', 'HELL'];

        const MAX_WORLDS = 6;
        const WAVES_PER_WORLD = 11;

        function clampInt(n, min, max) {
            n = parseInt(String(n), 10);
            if (!Number.isFinite(n)) n = min;
            return Math.max(min, Math.min(max, n));
        }

        function loadBestWaveReached() {
            const savedBest = localStorage.getItem('neonVoid_bestWave');
            if (savedBest !== null && savedBest !== undefined && savedBest !== '') {
                return clampInt(savedBest, 1, 999);
            }

            // Back-compat migration: older builds stored only a max world.
            const savedMaxWorld = localStorage.getItem('neonVoid_maxWorld');
            if (savedMaxWorld !== null && savedMaxWorld !== undefined && savedMaxWorld !== '') {
                const mw = clampInt(savedMaxWorld, 1, MAX_WORLDS);
                const inferredBestWave = (mw - 1) * WAVES_PER_WORLD + 1;
                localStorage.setItem('neonVoid_bestWave', String(inferredBestWave));
                return inferredBestWave;
            }

            return 1;
        }

        // World 1 is the only world unlocked by default.
        let bestWaveReached = loadBestWaveReached();
        let maxUnlockedWorld = 1;

        // Settings State
        let settings = {
            sound: true,
            world: maxUnlockedWorld, 
            difficultyIndex: 0,
            wave: '',
            password: ''
        };

        // Game State
        let gameState = {
            running: false, 
            score: 0,
            wave: 1,
            lives: 3,
            gameOver: false,
            paused: false,
            autoFire: false
        };

        // Inputs
        const keys = { w: false, a: false, d: false, space: false, shift: false };

        // Entity Lists
        let player;
        let bullets = [];
        let asteroids = [];
        let particles = [];
        let stars = [];
        let bonuses = [];
        
        // World 1 Enemies
        let ufos = [];
        let worms = [];
        let blackHoles = [];
        
        // World 2 Enemies
        let mines = [];
        let aegises = [];
        let hives = [];
        let drones = [];
        let lancers = [];
        let tethers = [];
        
        // World 3 Enemies
        let tornados = []; 
        let reflectors = [];
        let trailblazers = [];
        let orbitals = [];
        let prisms = [];
        let repulsors = [];

        // World 4 Enemies
        let staticBeetles = [];
        let phaseMantises = [];
        let sniperMosquitos = [];
        let clusterRoaches = [];
        let roachMites = [];
        let siphonFlies = [];
        let webWeavers = [];
        let webNodes = [];
        let hawkShooters = [];

        let nextWebGroupId = 1;
        let nextWebNodeId = 1;

        // Bosses
        let bossWorms = [];
        let bossLancers = [];
        let bossOrbitals = []; // New Boss List
        let bossArmorTimer = 0;
        
        // Shrapnel
        let mineShrapnels = [];

        // Constants
        const PLAYER_SIZE = 15;
        const FRICTION = 0.98;
        // Tier constants for enemy sizing and HP
        const TIER_SMALL = 1;
        const TIER_MED = 2;
        const TIER_LARGE = 3;
        const ACCELERATION = 0.15;
        const ROTATION_SPEED = 0.08;
        const BULLET_SPEED = 8;
        const BULLET_LIFETIME = 85;
        const BULLET_RECOIL = 0.2;
        const BASE_FIRE_RATE = 15;
        
        const ULT_CHARGE_TIME = 1800; 
        const ULT_DURATION = 120; 
        const LASER_WIDTH = 40;
        const LASER_LENGTH = 600;
        
        // Colors
        const COLOR_PLAYER = '#0ff';
        const COLOR_BULLET = '#ff0';
        const COLOR_ASTEROID = '#f0f';
        const COLOR_UFO = '#f00';
        const COLOR_WORM = '#0f8'; 
        const COLOR_BLACKHOLE = '#50f';
        const COLOR_MINE = '#f50';
        const COLOR_AEGIS = '#08f';
        const COLOR_HIVE = '#ff0';
        const COLOR_LANCER = '#f08';
        const COLOR_TETHER = '#b0f';
        
        const COLOR_TORNADO = '#0ff'; 
        const COLOR_REFLECTOR = '#ccc'; 
        const COLOR_TRAIL = '#0f0';
        const COLOR_ORBITAL_CORE = '#f00';
        const COLOR_ORBITAL_SHIELD = '#00f';
        const COLOR_PRISM = '#fff';
        const COLOR_REPULSOR = '#ff0';
        
        const COLOR_BONUS_SHOT = '#0ff';
        const COLOR_BONUS_RATE = '#fa0';
        const COLOR_BONUS_ARMOR = '#ff0';
        const COLOR_BONUS_HEALTH = '#f00';
        const COLOR_BONUS_EXPLODE = '#f50';
        const COLOR_BONUS_REVERSE = '#0ff';
        const COLOR_LASER = '#d0f';
        const DEBUG_PWD = '';

        // --- Menu Logic ---
        function updateSetting(type, dir) {
            if (type === 'sound') {
                settings.sound = !settings.sound;
                document.getElementById('val-sound').innerText = settings.sound ? 'ON' : 'OFF';
            } else if (type === 'world') {
                settings.world += dir;
                if (settings.world < 1) settings.world = maxUnlockedWorld;
                if (settings.world > maxUnlockedWorld) settings.world = 1;
                document.getElementById('val-world').innerText = settings.world;
            } else if (type === 'difficulty') {
                settings.difficultyIndex += dir;
                if (settings.difficultyIndex < 0) settings.difficultyIndex = difficulties.length - 1;
                if (settings.difficultyIndex >= difficulties.length) settings.difficultyIndex = 0;
                document.getElementById('val-difficulty').innerText = difficulties[settings.difficultyIndex];
            }
        }

        function startGameFromMenu() {
            document.getElementById('main-menu').style.display = 'none';
            document.getElementById('ui-layer').style.display = 'block';
            document.getElementById('game-controls-hint').style.display = 'block';
            gameState.running = true;

            // Read optional debug wave/password
            const waveInputEl = document.getElementById('wave-input');
            const wavePassEl = document.getElementById('wave-password');
            let debugWave = 0;
            if (waveInputEl) {
                debugWave = parseInt(waveInputEl.value || '0', 10) || 0;
            }
            const debugPassword = wavePassEl ? wavePassEl.value : '';

            if (debugPassword === 'debug' && debugWave >= 1 && debugWave <= 999) {
                // Directly jump to selected wave when debug password is correct
                gameState.lives = 999; // infinite lives for debugging
                gameState.wave = debugWave;
            } else {
                // Calculate starting wave based on world
                let startWaveNum = (settings.world - 1) * 11 + 1;
                gameState.wave = startWaveNum;
            }

            // Clear password field for safety
            if (wavePassEl) wavePassEl.value = '';
            resetGame();
        }

        function returnToMenu() {
            document.getElementById('game-over-screen').style.display = 'none';
            document.getElementById('ui-layer').style.display = 'none';
            document.getElementById('game-controls-hint').style.display = 'none';
            document.getElementById('main-menu').style.display = 'flex';
            gameState.running = false;
            
            settings.world = maxUnlockedWorld;
            document.getElementById('val-world').innerText = settings.world;
        }

        function getUnlockedWorldForWave(wave) {
            const safeWave = Math.max(1, parseInt(String(wave), 10) || 1);
            const unlocked = Math.floor((safeWave - 1) / WAVES_PER_WORLD) + 1;
            return clampInt(unlocked, 1, MAX_WORLDS);
        }

        // Initialize unlocked worlds from saved progress.
        maxUnlockedWorld = getUnlockedWorldForWave(bestWaveReached);

        function checkUnlocks() {
            bestWaveReached = Math.max(bestWaveReached, Math.max(1, parseInt(String(gameState.wave), 10) || 1));
            localStorage.setItem('neonVoid_bestWave', String(bestWaveReached));

            const unlockedNow = getUnlockedWorldForWave(bestWaveReached);
            if (unlockedNow > maxUnlockedWorld) maxUnlockedWorld = unlockedNow;

            // Keep writing legacy key for older code paths / existing saves.
            localStorage.setItem('neonVoid_maxWorld', String(maxUnlockedWorld));
        }


        // --- Helper ---
        function dist(o1, o2) { return Math.sqrt((o1.x - o2.x)**2 + (o1.y - o2.y)**2); }

        function pointToSegmentDistance(px, py, ax, ay, bx, by) {
            const abx = bx - ax; const aby = by - ay;
            const apx = px - ax; const apy = py - ay;
            const abLen2 = abx * abx + aby * aby;
            if (abLen2 === 0) return Math.sqrt(apx * apx + apy * apy);
            let t = (apx * abx + apy * aby) / abLen2;
            t = Math.max(0, Math.min(1, t));
            const projX = ax + t * abx;
            const projY = ay + t * aby;
            const dx = px - projX; const dy = py - projY;
            return Math.sqrt(dx * dx + dy * dy);
        }

        // --- Classes (Enemies & Objects) ---
        
        class BossOrbital {
            constructor(x, y) {
                this.x = x; this.y = y;
                this.scale = 5;
                this.hp = 200; this.maxHp = this.hp;
                this.size = 15 * this.scale; // Core size: 75
                this.vx = 0; this.vy = 0;
                this.orbAngle = 0;
                this.orbDist = 40 * this.scale; // Inner shield dist: 200
                this.orbSize = 8 * this.scale;  // Inner shield size: 40
                this.specialTimer = 0;
                this.outerActive = false;
                this.outerOrbs = 8;
            }
            update(player) {
                // Movement (slow pursuit)
                if(player) {
                    const dx = player.x - this.x; const dy = player.y - this.y;
                    const d = Math.sqrt(dx*dx + dy*dy);
                    if (d > 0) { this.vx += (dx/d) * 0.03; this.vy += (dy/d) * 0.03; }
                }
                this.x += this.vx; this.y += this.vy;
                const s = Math.sqrt(this.vx**2 + this.vy**2);
                if (s > 1.5) { this.vx *= 0.95; this.vy *= 0.95; } 

                this.orbAngle += 0.03;

                // Boundary containment
                if(this.x < -150) this.x = canvas.width+150; if(this.x > canvas.width+150) this.x = -150;
                if(this.y < -150) this.y = canvas.height+150; if(this.y > canvas.height+150) this.y = -150;

                // Special Ability: Summon Outer Circle
                this.specialTimer++;
                if (!this.outerActive) {
                    if (this.specialTimer > 300) { // 5 seconds (60fps * 5)
                        this.outerActive = true;
                        this.specialTimer = 0;
                        playSound('enemyShoot'); 
                    }
                } else {
                    if (this.specialTimer > 120) {
                        this.outerActive = false;
                        this.specialTimer = 0;
                    }
                }
            }
            takeDamage(amount) { this.hp -= amount; return this.hp <= 0; }
            draw(ctx) {
                ctx.save(); ctx.translate(this.x, this.y);

                // Draw Outer "Gravity" Orbs if active
                if (this.outerActive) {
                     ctx.fillStyle = '#b0f'; 
                     ctx.shadowColor = '#b0f'; ctx.shadowBlur = 20;
                     const outerDist = this.orbDist * 2.5; // ~500px radius
                     const orbCount = 12;
                     for(let k=0; k<orbCount; k++) {
                         const a = -this.orbAngle + (k/orbCount)*Math.PI*2;
                         const ox = Math.cos(a) * outerDist; 
                         const oy = Math.sin(a) * outerDist;
                         ctx.beginPath(); ctx.arc(ox, oy, 25, 0, Math.PI*2); ctx.fill();
                     }
                } else if (this.specialTimer > 240) {
                     // Warning flash before spawn
                     if (Math.floor(Date.now()/100)%2===0) {
                         ctx.strokeStyle = 'rgba(187, 0, 255, 0.3)'; ctx.lineWidth = 5;
                         ctx.beginPath(); ctx.arc(0, 0, this.orbDist * 2.5, 0, Math.PI*2); ctx.stroke();
                     }
                }

                // Core
                ctx.strokeStyle = '#f00'; ctx.shadowColor = '#f00'; ctx.shadowBlur = 20;
                ctx.lineWidth = 4;
                ctx.scale(this.scale, this.scale);
                ctx.beginPath(); ctx.arc(0,0,15,0,Math.PI*2); ctx.stroke(); // Core Circle
                ctx.fillStyle = '#500'; ctx.fill();

                // Inner Shield Orbs
                ctx.fillStyle = '#00f'; ctx.shadowColor = '#00f';
                for(let i=0; i<3; i++) {
                    const a = this.orbAngle + (i/3)*Math.PI*2;
                    const ox = Math.cos(a) * 40; const oy = Math.sin(a) * 40;
                    ctx.beginPath(); ctx.arc(ox, oy, 8, 0, Math.PI*2); ctx.fill();
                }
                
                ctx.scale(1/this.scale, 1/this.scale);
                drawHpBar(ctx, this.hp, this.maxHp, 70 * this.scale, this.scale);
                ctx.restore();
            }
        }
        
        class BossWorm {
            constructor(x, y, type = 'fast') {
                this.tier = 4; this.scale = 5; 
                if (type == 'fast') { this.hp = 55; } else { this.hp = 65; }; 
                this.maxHp = this.hp;
                this.type = type; // 'fast' or 'dasher'
                this.head = { x, y };
                this.segments = [];
                for(let i = 0; i < 12; i++) this.segments.push({ x, y });
                this.angle = 0;
                this.baseSpeed = this.type === 'fast' ? 3.5 : 3;
                this.speed = this.baseSpeed;
                this.dashTimer = 0; this.isDashing = false;
                this.wiggleTime = Math.random() * 100;
                this.radius = 8 * this.scale;
                this.cycleTimer = 0; this.isInvincible = false;
                this.ant1 = {x:0, y:0}; this.ant2 = {x:0, y:0};
            }
            update(player) {
                if (!player) return;
                this.cycleTimer++;
                if (this.cycleTimer > 600) { 
                    this.isInvincible = true;
                    if (this.cycleTimer > 720) { this.isInvincible = false; this.cycleTimer = 0; }
                }
                if (this.type === 'dasher') {
                    this.dashTimer++;
                    if (!this.isDashing) {
                        if (this.dashTimer > 300) { this.isDashing = true; this.dashTimer = 0; this.speed = 5.5; }
                    } else {
                        // Dash duration: 160 frames @60fps
                        if (this.dashTimer > 160) { this.isDashing = false; this.dashTimer = 0; this.speed = this.baseSpeed; }
                    }
                }
                // Wrap-aware chasing: use the shortest vector on a toroidal screen.
                let dx = player.x - this.head.x;
                let dy = player.y - this.head.y;
                if (Math.abs(dx) > canvas.width / 2) dx -= Math.sign(dx) * canvas.width;
                if (Math.abs(dy) > canvas.height / 2) dy -= Math.sign(dy) * canvas.height;
                const targetAngle = Math.atan2(dy, dx);
                let diff = targetAngle - this.angle;
                while (diff < -Math.PI) diff += Math.PI * 2;
                while (diff > Math.PI) diff -= Math.PI * 2;
                this.angle += Math.sign(diff) * Math.min(Math.abs(diff), 0.04); 
                this.wiggleTime += 0.1;
                const wiggle = Math.sin(this.wiggleTime) * 0.3;
                this.head.x += Math.cos(this.angle + wiggle) * this.speed;
                this.head.y += Math.sin(this.angle + wiggle) * this.speed;
                // Wrap instead of bouncing off borders.
                if (this.head.x < 0) this.head.x += canvas.width;
                if (this.head.x > canvas.width) this.head.x -= canvas.width;
                if (this.head.y < 0) this.head.y += canvas.height;
                if (this.head.y > canvas.height) this.head.y -= canvas.height;
                let prev = this.head;
                for(let i = 0; i < this.segments.length; i++) {
                    let seg = this.segments[i];
                    const distRaw = Math.sqrt((prev.x - seg.x)**2 + (prev.y - seg.y)**2);
                    if (distRaw > 100) { seg.x = prev.x; seg.y = prev.y; }
                    const dx = prev.x - seg.x; const dy = prev.y - seg.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    const angle = Math.atan2(dy, dx);
                    const spacing = 10 * this.scale;
                    if (dist > spacing) {
                        seg.x = prev.x - Math.cos(angle) * spacing;
                        seg.y = prev.y - Math.sin(angle) * spacing;
                    }
                    prev = seg;
                }
                // antennae geometry of worm boss
                const antDist = this.radius + 90; const antAngle = 0.76;
                this.ant1.x = this.head.x + Math.cos(this.angle - antAngle) * antDist;
                this.ant1.y = this.head.y + Math.sin(this.angle - antAngle) * antDist;
                this.ant2.x = this.head.x + Math.cos(this.angle + antAngle) * antDist;
                this.ant2.y = this.head.y + Math.sin(this.angle + antAngle) * antDist;
            }
            takeDamage(amount) { if (this.isInvincible) return false; this.hp -= amount; return this.hp <= 0; }
            draw(ctx) {
                ctx.save();
                if (this.isInvincible) { ctx.strokeStyle = '#fff'; ctx.fillStyle = '#fcc'; ctx.shadowColor = '#fff'; ctx.shadowBlur = 40; } 
                else { ctx.strokeStyle = '#f00'; ctx.fillStyle = '#600'; ctx.shadowColor = '#f00'; ctx.shadowBlur = 20; }

                // Draw antennae using wrap-aware shortest segments to avoid long cross-screen lines.
                const W = canvas.width; const H = canvas.height;
                const wrapPointNear = (ax, ay, bx, by) => {
                    let x = bx; let y = by;
                    let dx = x - ax; let dy = y - ay;
                    if (Math.abs(dx) > W / 2) x -= Math.sign(dx) * W;
                    if (Math.abs(dy) > H / 2) y -= Math.sign(dy) * H;
                    return { x, y };
                };
                const drawWrappedLine = (ax, ay, bx, by) => {
                    const p = wrapPointNear(ax, ay, bx, by);
                    ctx.beginPath(); ctx.moveTo(ax, ay); ctx.lineTo(p.x, p.y); ctx.stroke();
                    const sx = (p.x < 0) ? W : (p.x > W) ? -W : 0;
                    const sy = (p.y < 0) ? H : (p.y > H) ? -H : 0;
                    if (sx !== 0 || sy !== 0) {
                        ctx.beginPath(); ctx.moveTo(ax + sx, ay + sy); ctx.lineTo(p.x + sx, p.y + sy); ctx.stroke();
                    }
                    return p;
                };

                ctx.beginPath(); ctx.arc(this.head.x, this.head.y, this.radius, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
                for(let i = 0; i < this.segments.length; i++) {
                    const s = this.segments[i]; const size = (6 * this.scale) * (1 - i/14) + 5;
                    ctx.beginPath(); ctx.arc(s.x, s.y, size, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
                }
                ctx.lineWidth = 2;
                const a1 = drawWrappedLine(this.head.x, this.head.y, this.ant1.x, this.ant1.y);
                const a2 = drawWrappedLine(this.head.x, this.head.y, this.ant2.x, this.ant2.y);

                // Electric arc between antenna tips (also wrap-aware)
                ctx.strokeStyle = '#0ff'; ctx.shadowColor = '#0ff';
                const midX = (a1.x + a2.x) / 2 + (Math.random() - 0.5) * 10;
                const midY = (a1.y + a2.y) / 2 + (Math.random() - 0.5) * 10;
                ctx.beginPath(); ctx.moveTo(a1.x, a1.y); ctx.lineTo(midX, midY); ctx.lineTo(a2.x, a2.y); ctx.stroke();
                // If points are outside view due to wrapping, draw a shifted copy
                const sx = ((a1.x < 0 || a2.x < 0) ? W : (a1.x > W || a2.x > W) ? -W : 0);
                const sy = ((a1.y < 0 || a2.y < 0) ? H : (a1.y > H || a2.y > H) ? -H : 0);
                if (sx !== 0 || sy !== 0) {
                    ctx.beginPath();
                    ctx.moveTo(a1.x + sx, a1.y + sy);
                    ctx.lineTo(midX + sx, midY + sy);
                    ctx.lineTo(a2.x + sx, a2.y + sy);
                    ctx.stroke();
                }
                drawHpBar(ctx, this.hp, this.maxHp, this.radius + 20, this.scale, 0, this.head.x, this.head.y);
                ctx.restore();
            }
        }
        
        class BossLancer {
            constructor(x, y) {
                this.x = x; this.y = y; this.scale = 3.25;
                this.hp = 22; this.maxHp = this.hp;
                this.size = 15 * this.scale;
                this.vx = 0; this.vy = 0; this.angle = 0;
                this.state = 0; this.moveTimer = Math.random() * 100;
                this.abilityTimer = 0; this.isInvincible = false;
                this.laserActive = false; this.laserAngle = 0;
            }
            update(player) {
                if (!player) return;
                this.abilityTimer++;
                if (this.abilityTimer > 300) { this.isInvincible = true; }
                if (this.abilityTimer > 360) {
                    this.isInvincible = false; this.laserActive = true;
                    this.laserAngle = Math.atan2(player.y - this.y, player.x - this.x);
                    this.abilityTimer = 0;
                }
                if (this.state === 0) {
                    this.moveTimer++; this.x += this.vx; this.y += this.vy; this.vx *= 0.75; this.vy *= 0.75;
                    const dx = player.x - this.x; const dy = player.y - this.y;
                    this.angle = Math.atan2(dy, dx);
                    if (this.moveTimer > 100) { this.state = 1; this.moveTimer = 0; }
                } else if (this.state === 1) {
                    this.moveTimer++; const dx = player.x - this.x; const dy = player.y - this.y;
                    this.angle = Math.atan2(dy, dx);
                    if (this.moveTimer > 50) {
                        this.state = 2; this.moveTimer = 0; const s = 14; 
                        this.vx = Math.cos(this.angle) * s; this.vy = Math.sin(this.angle) * s;
                    }
                } else if (this.state === 2) {
                    this.moveTimer++; this.x += this.vx; this.y += this.vy;
                    if (this.moveTimer > 25) { this.state = 0; this.moveTimer = 0; }
                }
                if (this.x < -60) this.x = canvas.width + 60; if (this.x > canvas.width + 60) this.x = -60;
                if (this.y < -60) this.y = canvas.height + 60; if (this.y > canvas.height + 60) this.y = -60;
            }
            takeDamage(amount) { if (this.isInvincible) return false; this.hp -= amount; return this.hp <= 0; }
            draw(ctx) {
                ctx.save(); ctx.translate(this.x, this.y); 
                if (this.laserActive && this.abilityTimer < 15) {
                     ctx.save(); ctx.rotate(this.laserAngle); ctx.strokeStyle = '#f00'; ctx.lineWidth = 10;
                     ctx.shadowColor = '#f00'; ctx.shadowBlur = 20; ctx.beginPath(); ctx.moveTo(30, 0); ctx.lineTo(300, 0); ctx.stroke();
                     ctx.restore(); this.abilityTimer++;
                     if(this.abilityTimer >= 15) { this.laserActive = false; this.abilityTimer = 0; }
                }
                ctx.rotate(this.angle);
                if (this.isInvincible) { ctx.strokeStyle = '#fff'; ctx.shadowColor = '#fff'; ctx.shadowBlur = 30; } 
                else { ctx.strokeStyle = COLOR_LANCER; ctx.shadowColor = COLOR_LANCER; ctx.shadowBlur = 15; }
                ctx.lineWidth = 3; ctx.scale(this.scale, this.scale);
                ctx.beginPath(); ctx.moveTo(15,0); ctx.lineTo(-10, 8); ctx.lineTo(-5, 0); ctx.lineTo(-10, -8); ctx.closePath(); ctx.stroke();
                ctx.fillStyle = this.isInvincible ? '#fff' : COLOR_LANCER; ctx.globalAlpha = 0.3; ctx.fill(); ctx.globalAlpha = 1.0;
                ctx.scale(1/this.scale, 1/this.scale);
                if (this.state !== 2) drawHpBar(ctx, this.hp, this.maxHp, 30*this.scale, this.scale, -this.angle);
                ctx.restore();
            }
        }

        class Star {
            constructor() {
                this.x = Math.random() * canvas.width; this.y = Math.random() * canvas.height;
                this.size = 1.5 + Math.random() * 2.5; this.baseAlpha = 0.4 + Math.random() * 0.4; 
                this.blinkOffset = Math.random() * Math.PI * 2; this.color = '255, 255, 255';
            }
            update() {}
            draw(ctx) {
                const alpha = Math.max(0.2, this.baseAlpha + Math.sin(Date.now() * 0.005 + this.blinkOffset) * 0.2);
                ctx.fillStyle = `rgba(${this.color}, ${alpha})`; ctx.shadowBlur = 0; 
                ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill();
            }
        }

        class Particle {
            constructor(x, y, color, speed, size, life) {
                this.x = x; this.y = y; this.color = color;
                const angle = Math.random() * Math.PI * 2; const vel = Math.random() * speed;
                this.vx = Math.cos(angle) * vel; this.vy = Math.sin(angle) * vel;
                this.life = life; this.maxLife = life; this.size = size;
            }
            update() { this.x += this.vx; this.y += this.vy; this.life--; }
            draw(ctx) {
                ctx.globalAlpha = this.life / this.maxLife; ctx.fillStyle = this.color;
                ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }

        class Bullet {
            constructor(x, y, angle, owner = 'player') {
                this.x = x; this.y = y;
                this.speed = owner === 'player' ? BULLET_SPEED : BULLET_SPEED * 0.6;
                this.vx = Math.cos(angle) * this.speed; this.vy = Math.sin(angle) * this.speed;
                this.life = BULLET_LIFETIME; this.owner = owner;
            }
            update() {
                this.x += this.vx; this.y += this.vy; this.life--;
                if (this.x < -50) this.x = canvas.width + 50; if (this.x > canvas.width + 50) this.x = -50;
                if (this.y < -50) this.y = canvas.height + 50; if (this.y > canvas.height + 50) this.y = -50;
            }
            draw(ctx) {
                ctx.strokeStyle = this.owner === 'player' ? COLOR_BULLET : '#f00';
                ctx.lineWidth = 2; ctx.shadowColor = ctx.strokeStyle; ctx.shadowBlur = 10;
                ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(this.x - this.vx * 1.5, this.y - this.vy * 1.5); ctx.stroke();
            }
        }

        class Bonus {
            constructor(x, y, type = -1) {
                this.x = x; this.y = y;
                this.type = type !== -1 ? type : Math.floor(Math.random() * 6);
                this.life = 1200; this.size = 12;
                this.vx = (Math.random() - 0.5) * 0.5; this.vy = (Math.random() - 0.5) * 0.5;
                // Icons drawn procedurally now
                this.color = [COLOR_BONUS_SHOT, COLOR_BONUS_RATE, COLOR_BONUS_ARMOR, COLOR_BONUS_HEALTH, COLOR_BONUS_EXPLODE, COLOR_BONUS_REVERSE][this.type];
            }
            update() {
                this.x += this.vx; this.y += this.vy; this.life--;
                if(this.x < 0 || this.x > canvas.width) this.vx *= -1;
                if(this.y < 0 || this.y > canvas.height) this.vy *= -1;
            }
            draw(ctx) {
                if (this.life < 120 && Math.floor(Date.now() / 100) % 2 === 0) return;
                ctx.save(); ctx.translate(this.x, this.y);
                ctx.strokeStyle = this.color; ctx.fillStyle = this.color; ctx.shadowColor = this.color; ctx.shadowBlur = 10;
                
                // Box
                ctx.lineWidth = 2;
                ctx.strokeRect(-12, -12, 24, 24); 
                
                // Icon Drawing
                ctx.beginPath();
                if (this.type === 0) { // Multi-Shot (Spread)
                    ctx.moveTo(0, 5); ctx.lineTo(0, -5);
                    ctx.moveTo(-4, 3); ctx.lineTo(-7, -3);
                    ctx.moveTo(4, 3); ctx.lineTo(7, -3);
                } else if (this.type === 1) { // Rapid (Lightning)
                    ctx.moveTo(3, -6); ctx.lineTo(-2, -1); ctx.lineTo(2, -1); ctx.lineTo(-3, 6);
                } else if (this.type === 2) { // Armor (Shield)
                    ctx.moveTo(-5, -4); ctx.lineTo(5, -4); ctx.lineTo(5, 1); 
                    ctx.quadraticCurveTo(0, 7, -5, 1); ctx.closePath();
                } else if (this.type === 3) { // Health (Cross)
                    ctx.moveTo(0, -6); ctx.lineTo(0, 6); 
                    ctx.moveTo(-6, 0); ctx.lineTo(6, 0);
                } else if (this.type === 4) { // Explode (Burst)
                    for(let i=0; i<8; i++) {
                        const a = (i/8)*Math.PI*2;
                        ctx.moveTo(Math.cos(a)*3, Math.sin(a)*3); 
                        ctx.lineTo(Math.cos(a)*7, Math.sin(a)*7);
                    }
                } else if (this.type === 5) { // Reverse (Arrow)
                    ctx.arc(0, 3, 4, Math.PI, 0); // Bottom curve
                    ctx.moveTo(4, 3); ctx.lineTo(4, -5); // Up line
                    ctx.lineTo(1, -2); ctx.moveTo(4, -5); ctx.lineTo(7, -2); // Arrowhead
                }
                ctx.stroke();
                
                ctx.restore();
            }
        }

        class BlackHole {
            constructor(x, y, tier = 1) {
                this.x = x; this.y = y; this.tier = tier;
                this.scale = tier === TIER_LARGE ? 2 : (tier === TIER_MED ? 1.5 : 1);
                this.hp = tier === TIER_LARGE ? 5 : (tier === TIER_MED ? 3 : 1); this.maxHp = this.hp;
                this.size = 25 * this.scale; this.pullRadius = 300 * this.scale;
                let forceMultiplier = this.scale > 1 ? 0.75 : 1;
                this.pullForce = 0.125 * this.scale * forceMultiplier;
                this.vx = (Math.random() - 0.5) * 0.3; this.vy = (Math.random() - 0.5) * 0.3; this.angle = 0;
            }
            update(player) {
                this.x += this.vx; this.y += this.vy; this.angle += 0.05;
                if(this.x < -this.size) this.x = canvas.width + this.size; else if(this.x > canvas.width + this.size) this.x = -this.size;
                if(this.y < -this.size) this.y = canvas.height + this.size; else if(this.y > canvas.height + this.size) this.y = -this.size;
            }
            takeDamage(amount) { this.hp -= amount; return this.hp <= 0; }
            draw(ctx) {
                ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle);
                ctx.strokeStyle = COLOR_BLACKHOLE; ctx.lineWidth = 2 * this.scale; ctx.shadowColor = COLOR_BLACKHOLE; ctx.shadowBlur = 15;
                for(let i=0; i<8; i++) { ctx.rotate((Math.PI * 2) / 8); ctx.beginPath(); ctx.moveTo(this.size * 0.8, 0); ctx.lineTo(this.size * 1.4, 0); ctx.stroke(); }
                ctx.beginPath(); ctx.arc(0, 0, this.size * 0.8, 0, Math.PI * 2); ctx.fillStyle = '#000'; ctx.shadowBlur = 5; ctx.fill();
                ctx.strokeStyle = '#309'; ctx.lineWidth = 2; ctx.stroke();
                drawHpBar(ctx, this.hp, this.maxHp, this.size + 15, this.scale, -this.angle);
                ctx.restore();
            }
        }

        class SpaceWorm {
            constructor(x, y, tier = 1) {
                this.tier = tier; this.scale = tier === TIER_LARGE ? 2 : (tier === TIER_MED ? 1.5 : 1);
                this.hp = tier === TIER_LARGE ? 9 : (tier === TIER_MED ? 7 : 2); this.maxHp = this.hp;
                this.head = { x, y }; this.segments = []; for(let i = 0; i < 8; i++) this.segments.push({ x, y });
                this.angle = 0; this.speed = (3 * (1/this.scale)); 
                this.wiggleTime = Math.random() * 100; this.radius = 8 * this.scale;
            }
            update(player) {
                if (!player) return;
                const isAggro = keys.space || (player && player.ultActive);
                if (isAggro) {
                    const dx = player.x - this.head.x; const dy = player.y - this.head.y;
                    const targetAngle = Math.atan2(dy, dx);
                    let diff = targetAngle - this.angle;
                    while (diff < -Math.PI) diff += Math.PI * 2;
                    while (diff > Math.PI) diff -= Math.PI * 2;
                    this.angle += Math.sign(diff) * Math.min(Math.abs(diff), 0.05);
                } else { this.angle += (Math.random() - 0.5) * 0.1; }
                this.wiggleTime += 0.2; const wiggle = Math.sin(this.wiggleTime) * 0.6;
                this.head.x += Math.cos(this.angle + wiggle) * this.speed;
                this.head.y += Math.sin(this.angle + wiggle) * this.speed;
                if (this.head.x < -40) this.head.x = canvas.width + 40; if (this.head.x > canvas.width + 40) this.head.x = -40;
                if (this.head.y < -40) this.head.y = canvas.height + 40; if (this.head.y > canvas.height + 40) this.head.y = -40;
                let prev = this.head;
                for(let i = 0; i < this.segments.length; i++) {
                    let seg = this.segments[i];
                    const distRaw = Math.sqrt((prev.x - seg.x)**2 + (prev.y - seg.y)**2);
                    if (distRaw > 100) { seg.x = prev.x; seg.y = prev.y; }
                    const dx = prev.x - seg.x; const dy = prev.y - seg.y;
                    const dist = Math.sqrt(dx*dx + dy*dy); const angle = Math.atan2(dy, dx);
                    if (dist > 12 * this.scale) { seg.x = prev.x - Math.cos(angle) * (12 * this.scale); seg.y = prev.y - Math.sin(angle) * (12 * this.scale); }
                    prev = seg;
                }
            }
            takeDamage(amount) { this.hp -= amount; return this.hp <= 0; }
            draw(ctx) {
                ctx.save(); ctx.strokeStyle = COLOR_WORM; ctx.fillStyle = COLOR_WORM; ctx.shadowColor = COLOR_WORM; ctx.shadowBlur = 10;
                ctx.beginPath(); ctx.arc(this.head.x, this.head.y, this.radius, 0, Math.PI * 2); ctx.fill();
                for(let i = 0; i < this.segments.length; i++) {
                    ctx.beginPath(); ctx.arc(this.segments[i].x, this.segments[i].y, (6 * this.scale) * (1 - i/8) + 2, 0, Math.PI * 2); ctx.stroke();
                }
                drawHpBar(ctx, this.hp, this.maxHp, this.radius + 10, this.scale, 0, this.head.x, this.head.y);
                ctx.restore();
            }
        }

        class Ufo {
            constructor(x, y, tier = 1) {
                this.x = x; this.y = y; this.tier = tier;
                this.scale = tier === TIER_LARGE ? 2 : (tier === TIER_MED ? 1.5 : 1);
                this.hp = tier === TIER_LARGE ? 7 : (tier === TIER_MED ? 5 : 2); this.maxHp = this.hp;
                this.size = 20 * this.scale;
                this.vx = (Math.random() - 0.5) * 3; this.vy = (Math.random() - 0.5) * 3;
                this.fireCooldown = 100 + Math.random() * 100; this.changeDirTimer = 0;
            }
            update(player) {
                this.x += this.vx; this.y += this.vy; this.changeDirTimer--;
                if (this.changeDirTimer <= 0) {
                    this.changeDirTimer = 60 + Math.random() * 100;
                    if (player && Math.random() > 0.4) {
                        const angle = Math.atan2(player.y - this.y, player.x - this.x);
                        this.vx = Math.cos(angle) * 2; this.vy = Math.sin(angle) * 2;
                    } else { this.vx = (Math.random() - 0.5) * 4; this.vy = (Math.random() - 0.5) * 4; }
                }
                this.fireCooldown--;
                if (this.fireCooldown <= 0 && player) {
                    const angle = Math.atan2(player.y - this.y, player.x - this.x);
                    bullets.push(new Bullet(this.x, this.y, angle, 'enemy'));
                    this.fireCooldown = 80; playSound('enemyShoot');
                }
                if (this.x < -40) this.x = canvas.width + 40; if (this.x > canvas.width + 40) this.x = -40;
                if (this.y < -40) this.y = canvas.height + 40; if (this.y > canvas.height + 40) this.y = -40;
            }
            takeDamage(amount) { this.hp -= amount; return this.hp <= 0; }
            draw(ctx) {
                ctx.save(); ctx.translate(this.x, this.y); ctx.strokeStyle = COLOR_UFO;
                ctx.shadowColor = COLOR_UFO; ctx.shadowBlur = 10; ctx.lineWidth = 2;
                ctx.scale(this.scale, this.scale);
                ctx.beginPath(); ctx.ellipse(0, 5, 20, 8, 0, 0, Math.PI * 2); ctx.stroke();
                ctx.beginPath(); ctx.arc(0, 0, 10, Math.PI, 0); ctx.stroke();
                ctx.scale(1/this.scale, 1/this.scale);
                drawHpBar(ctx, this.hp, this.maxHp, 30 * this.scale, this.scale);
                ctx.restore();
            }
        }

        class Asteroid {
            constructor(x, y, size, tier) {
                this.x = x; this.y = y; this.size = size; this.tier = tier;
                const angle = Math.random() * Math.PI * 2;
                const speed = (Math.random() * 1.5 + 0.5) / tier;
                this.vx = Math.cos(angle) * speed; this.vy = Math.sin(angle) * speed;
                this.rotation = 0; this.rotSpeed = (Math.random() - 0.5) * 0.05;
                this.vertices = []; const numVerts = 5 + Math.floor(Math.random() * 5);
                for (let i = 0; i < numVerts; i++) {
                    const a = (i / numVerts) * Math.PI * 2; const r = this.size * (0.8 + Math.random() * 0.4);
                    this.vertices.push({ x: Math.cos(a) * r, y: Math.sin(a) * r });
                }
            }
            update(playerPos) {
                this.x += this.vx; this.y += this.vy; this.rotation += this.rotSpeed;
                if (this.tier > 1 && playerPos) {
                    const dx = playerPos.x - this.x; const dy = playerPos.y - this.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist > 0 && dist < 400) { this.vx += (dx / dist) * 0.005; this.vy += (dy / dist) * 0.005; }
                }
                if (this.x < -this.size) this.x = canvas.width + this.size; if (this.x > canvas.width + this.size) this.x = -this.size;
                if (this.y < -this.size) this.y = canvas.height + this.size; if (this.y > canvas.height + this.size) this.y = -this.size;
            }
            draw(ctx) {
                ctx.strokeStyle = COLOR_ASTEROID; ctx.lineWidth = 2; ctx.shadowColor = COLOR_ASTEROID; ctx.shadowBlur = 15;
                ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.rotation);
                ctx.beginPath(); ctx.moveTo(this.vertices[0].x, this.vertices[0].y);
                for (let i = 1; i < this.vertices.length; i++) ctx.lineTo(this.vertices[i].x, this.vertices[i].y);
                ctx.closePath(); ctx.stroke();
                ctx.fillStyle = COLOR_ASTEROID; ctx.globalAlpha = 0.1; ctx.fill(); ctx.globalAlpha = 1.0;
                ctx.restore();
            }
        }

        class Mine {
            constructor(x, y, size, tier) {
                this.x = x; this.y = y; this.size = size; this.tier = tier;
                const angle = Math.random() * Math.PI * 2;
                const speed = (Math.random() * 1.5 + 0.5) / tier * 0.8; 
                this.vx = Math.cos(angle) * speed; this.vy = Math.sin(angle) * speed;
                this.rotation = 0; this.rotSpeed = 0.02;
            }
            update(playerPos) {
                this.x += this.vx; this.y += this.vy; this.rotation += this.rotSpeed;
                if (this.x < -this.size) this.x = canvas.width + this.size; if (this.x > canvas.width + this.size) this.x = -this.size;
                if (this.y < -this.size) this.y = canvas.height + this.size; if (this.y > canvas.height + this.size) this.y = -this.size;
            }
            draw(ctx) {
                ctx.strokeStyle = COLOR_MINE; ctx.lineWidth = 2; ctx.shadowColor = COLOR_MINE; ctx.shadowBlur = 15;
                ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.rotation);
                ctx.beginPath();
                for(let i=0; i<8; i++) {
                    const r = i % 2 === 0 ? this.size : this.size * 0.5; const a = (i/8) * Math.PI * 2;
                    ctx.lineTo(Math.cos(a)*r, Math.sin(a)*r);
                }
                ctx.closePath(); ctx.stroke();
                if (Math.floor(Date.now()/200)%2===0) { ctx.fillStyle = COLOR_MINE; ctx.beginPath(); ctx.arc(0,0,4,0,Math.PI*2); ctx.fill(); }
                ctx.restore();
            }
        }

        class MineShrapnel {
            constructor(x, y, target, index) {
                this.x = x; this.y = y; this.size = 18; this.hp = 1;
                const angle = Math.atan2(target.y - y, target.x - x);
                const speed = 4 + Math.random();
                this.baseVx = Math.cos(angle) * speed; this.baseVy = Math.sin(angle) * speed;
                this.pVx = Math.cos(angle + Math.PI/2); this.pVy = Math.sin(angle + Math.PI/2);
                this.bx = x; this.by = y; this.t = index * (Math.PI / 2); this.amp = 2; 
            }
            update() {
                this.t += 0.2; this.bx += this.baseVx; this.by += this.baseVy;
                const offset = Math.sin(this.t) * this.amp;
                this.x = this.bx + this.pVx * offset; this.y = this.by + this.pVy * offset;
                if (this.x < -50 || this.x > canvas.width+50 || this.y < -50 || this.y > canvas.height+50) this.hp = 0;
            }
            takeDamage(amount) { this.hp = 0; return true; }
            draw(ctx) {
                ctx.save(); ctx.translate(this.x, this.y);
                ctx.fillStyle = COLOR_MINE; ctx.shadowColor = COLOR_MINE; ctx.shadowBlur = 5;
                ctx.beginPath(); ctx.moveTo(this.size, 0); ctx.lineTo(-this.size/2, this.size/2); ctx.lineTo(-this.size/2, -this.size/2); ctx.fill();
                ctx.restore();
            }
        }

        class Aegis {
            constructor(x, y, tier = 1) {
                this.x = x; this.y = y; this.tier = tier;
                this.scale = tier === TIER_LARGE ? 2 : (tier === TIER_MED ? 1.5 : 1);
                this.hp = tier === TIER_LARGE ? 5 : (tier === TIER_MED ? 3 : 1); this.maxHp = this.hp;
                this.size = 20 * this.scale;
                this.vx = (Math.random() - 0.5) * 2; this.vy = (Math.random() - 0.5) * 2; this.angle = 0;
            }
            update(player) {
                this.x += this.vx; this.y += this.vy;
                if (player) { this.angle = Math.atan2(player.y - this.y, player.x - this.x); }
                if (this.x < -40) this.x = canvas.width + 40; if (this.x > canvas.width + 40) this.x = -40;
                if (this.y < -40) this.y = canvas.height + 40; if (this.y > canvas.height + 40) this.y = -40;
            }
            takeDamage(amount) { this.hp -= amount; return this.hp <= 0; }
            draw(ctx) {
                ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle);
                ctx.strokeStyle = COLOR_AEGIS; ctx.lineWidth = 2; ctx.shadowColor = COLOR_AEGIS; ctx.shadowBlur = 10;
                ctx.scale(this.scale, this.scale);
                ctx.beginPath(); ctx.arc(0, 0, 15, 0, Math.PI * 2); ctx.stroke();
                ctx.lineWidth = 4; ctx.beginPath(); ctx.arc(0, 0, 22, -Math.PI/3, Math.PI/3); ctx.stroke();
                ctx.scale(1/this.scale, 1/this.scale); ctx.rotate(-this.angle);
                drawHpBar(ctx, this.hp, this.maxHp, 30 * this.scale, this.scale);
                ctx.restore();
            }
        }

        class Hive {
            constructor(x, y, tier = 1) {
                this.x = x; this.y = y; this.tier = tier;
                this.scale = tier === TIER_LARGE ? 2 : (tier === TIER_MED ? 1.5 : 1);
                this.hp = (tier === TIER_LARGE ? 6 : (tier === TIER_MED ? 4 : 1)) * 3; this.maxHp = this.hp;
                this.size = 30 * this.scale;
                const centerX = canvas.width / 2; const centerY = canvas.height / 2;
                const angleToCenter = Math.atan2(centerY - this.y, centerX - this.x);
                const driftAngle = angleToCenter + (Math.random() - 0.5); 
                this.vx = Math.cos(driftAngle) * 0.5; this.vy = Math.sin(driftAngle) * 0.5;
                this.spawnTimer = 0;
            }
            update(player) {
                this.x += this.vx; this.y += this.vy;
                if (this.x < -50) this.x = canvas.width + 50; if (this.x > canvas.width + 50) this.x = -50;
                if (this.y < -50) this.y = canvas.height + 50; if (this.y > canvas.height + 50) this.y = -50;
                this.spawnTimer++;
                if (this.spawnTimer > 300) { 
                    this.spawnTimer = 0;
                    if (drones.length < 20) { for(let i=0; i<this.tier; i++) drones.push(new Drone(this.x, this.y)); }
                }
            }
            takeDamage(amount) { this.hp -= amount; return this.hp <= 0; }
            draw(ctx) {
                ctx.save(); ctx.translate(this.x, this.y);
                ctx.strokeStyle = COLOR_HIVE; ctx.lineWidth = 2; ctx.shadowColor = COLOR_HIVE; ctx.shadowBlur = 10;
                ctx.scale(this.scale, this.scale);
                ctx.beginPath();
                for (let i = 0; i < 6; i++) { const a = (i/6)*Math.PI*2; ctx.lineTo(Math.cos(a)*25, Math.sin(a)*25); }
                ctx.closePath(); ctx.stroke();
                const s = 10 + Math.sin(Date.now()/200)*5; ctx.beginPath(); ctx.arc(0,0,s,0,Math.PI*2); ctx.stroke();
                ctx.scale(1/this.scale, 1/this.scale);
                drawHpBar(ctx, this.hp, this.maxHp, 40 * this.scale, this.scale);
                ctx.restore();
            }
        }

        class Drone {
            constructor(x, y) {
                this.x = x; this.y = y; this.size = 8;
                this.vx = (Math.random()-0.5)*4; this.vy = (Math.random()-0.5)*4; this.angle = 0;
            }
            update(player) {
                if (player) {
                    const dx = player.x - this.x; const dy = player.y - this.y;
                    const angle = Math.atan2(dy, dx);
                    this.vx += Math.cos(angle) * 0.1; this.vy += Math.sin(angle) * 0.1;
                    const s = Math.sqrt(this.vx**2 + this.vy**2);
                    if (s > 4) { this.vx *= 0.95; this.vy *= 0.95; }
                    this.angle = angle;
                }
                this.x += this.vx; this.y += this.vy;
            }
            draw(ctx) {
                ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle);
                ctx.strokeStyle = COLOR_HIVE; ctx.beginPath();
                ctx.moveTo(8, 0); ctx.lineTo(-5, 5); ctx.lineTo(-5, -5); ctx.closePath(); ctx.stroke();
                ctx.restore();
            }
        }

        class Lancer {
            constructor(x, y, tier = 1) {
                this.x = x; this.y = y; this.tier = tier;
                this.scale = tier === TIER_LARGE ? 2.22 : (tier === TIER_MED ? 1.65 : 1);
                const baseHp = tier === TIER_LARGE ? 6 : (tier === TIER_MED ? 4 : 1);
                this.hp = baseHp * 1.2; this.maxHp = this.hp;
                this.size = 15 * this.scale;
                this.vx = 0; this.vy = 0; this.angle = 0; this.state = 0; this.timer = Math.random() * 100;
            }
            update(player) {
                if (!player) return;
                if (this.state === 0) {
                    this.timer++; this.x += this.vx; this.y += this.vy; this.vx *= 0.95; this.vy *= 0.95;
                    const dx = player.x - this.x; const dy = player.y - this.y;
                    this.angle = Math.atan2(dy, dx);
                    if (this.timer > 120) { this.state = 1; this.timer = 0; }
                } else if (this.state === 1) {
                    this.timer++; const dx = player.x - this.x; const dy = player.y - this.y;
                    this.angle = Math.atan2(dy, dx);
                    if (this.timer > 60) {
                        this.state = 2; this.timer = 0; const s = 12; 
                        this.vx = Math.cos(this.angle) * s; this.vy = Math.sin(this.angle) * s;
                    }
                } else if (this.state === 2) {
                    this.timer++; this.x += this.vx; this.y += this.vy;
                    if (this.timer > 20) { this.state = 0; this.timer = 0; }
                }
                if (this.x < -40) this.x = canvas.width + 40; if (this.x > canvas.width + 40) this.x = -40;
                if (this.y < -40) this.y = canvas.height + 40; if (this.y > canvas.height + 40) this.y = -40;
            }
            takeDamage(amount) { this.hp -= amount; return this.hp <= 0; }
            draw(ctx) {
                ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle);
                ctx.strokeStyle = this.state === 1 ? '#fff' : COLOR_LANCER; 
                ctx.shadowColor = COLOR_LANCER; ctx.shadowBlur = 10; ctx.lineWidth = 2;
                ctx.scale(this.scale, this.scale);
                ctx.beginPath(); ctx.moveTo(15,0); ctx.lineTo(-10, 8); ctx.lineTo(-5, 0); ctx.lineTo(-10, -8); ctx.closePath(); ctx.stroke();
                ctx.scale(1/this.scale, 1/this.scale);
                if (this.state !== 2) drawHpBar(ctx, this.hp, this.maxHp, 30*this.scale, this.scale, -this.angle);
                ctx.restore();
            }
        }

        class TetherTwin {
            constructor(x, y, tier = 1, groupId = 0) {
                this.x = x; this.y = y; this.tier = tier;
                this.groupId = groupId;
                this.tetherId = (typeof window !== 'undefined' && window.__nextTetherId) ? (window.__nextTetherId++) : (TetherTwin.__nextId++);
                this.scale = tier === TIER_LARGE ? 2.5 : (tier === TIER_MED ? 1.8 : 1.3);
                this.hp = tier === TIER_LARGE ? 24 : (tier === TIER_MED ? 16 : 6); this.maxHp = this.hp;
                this.size = 15 * this.scale;
                this.vx = (Math.random()-0.5)*2; this.vy = (Math.random()-0.5)*2;
                this.dead = false;
            }

            static __nextId = 1;

            update() {
                this.x += this.vx; this.y += this.vy;
                // Light damping so movement feels less twitchy/violent.
                this.vx *= 0.985; this.vy *= 0.985;

                // Tiny per-node wander so the group doesn't lock into a single shared direction.
                this.vx += (Math.random() - 0.5) * 0.02;
                this.vy += (Math.random() - 0.5) * 0.02;

                // Nudge toward the group's constant velocity so members move together.
                if (this.groupVx !== undefined) {
                    const follow = 0.08; // how strongly they adhere to group velocity
                    this.vx += (this.groupVx - this.vx) * follow;
                    this.vy += (this.groupVy - this.vy) * follow;
                }
                if (this.x < -30) this.x = canvas.width + 30; if (this.x > canvas.width + 30) this.x = -30;
                if (this.y < -30) this.y = canvas.height + 30; if (this.y > canvas.height + 30) this.y = -30;

                // Cohesion: keep the triangle group somewhat together.
                const mates = tethers.filter(t => t && !t.dead && t.groupId === this.groupId && t !== this);
                if (mates.length > 0) {
                    // Pairwise spring: keeps nodes clustered, but allows them to get very close.
                    const restDist = 240 * this.scale;   // smaller = tighter cluster (can nearly overlap)
                    const kPair = 0.0015;                // spring strength
                    for (const m of mates) {
                        const dxm = m.x - this.x; const dym = m.y - this.y;
                        const dm = Math.sqrt(dxm*dxm + dym*dym);
                        if (dm > 0.001) {
                            const diff = dm - restDist;
                            const f = diff * kPair;
                            this.vx += (dxm / dm) * f;
                            this.vy += (dym / dm) * f;
                        }
                    }

                    let cx = this.x; let cy = this.y;
                    for (const m of mates) { cx += m.x; cy += m.y; }
                    cx /= (mates.length + 1);
                    cy /= (mates.length + 1);
                    const dx = cx - this.x; const dy = cy - this.y;
                    const d = Math.sqrt(dx*dx + dy*dy) || 1;

                    // Gentle centroid pull to prevent long separations.
                    const cohesion_thresh = 80;
                    if (d > cohesion_thresh) {
                        const pull = 0.008;
                        this.vx += (dx/d) * pull;
                        this.vy += (dy/d) * pull;
                    }

                    // Soft clamp (prevents sudden slingshots if they get separated).
                    const maxSpeed = 2.75;
                    const sp = Math.sqrt(this.vx*this.vx + this.vy*this.vy) || 0;
                    if (sp > maxSpeed) {
                        this.vx = (this.vx / sp) * maxSpeed;
                        this.vy = (this.vy / sp) * maxSpeed;
                    }
                }
            }

            takeDamage(amount) {
                this.hp -= amount;
                if (this.hp <= 0) { this.dead = true; return true; }
                return false;
            }

            draw(ctx) {
                // Draw beams to other living nodes in the same group, once per edge.
                const mates = tethers.filter(t => t && !t.dead && t.groupId === this.groupId);
                for (const other of mates) {
                    if (other === this) continue;
                    if (this.tetherId >= other.tetherId) continue;
                    ctx.strokeStyle = COLOR_TETHER; ctx.lineWidth = 4; ctx.shadowColor = COLOR_TETHER; ctx.shadowBlur = 10;
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    const midX = (this.x + other.x) / 2 + (Math.random() - 0.5) * 20;
                    const midY = (this.y + other.y) / 2 + (Math.random() - 0.5) * 20;
                    ctx.lineTo(midX, midY);
                    ctx.lineTo(other.x, other.y);
                    ctx.stroke();
                }

                ctx.save(); ctx.translate(this.x, this.y);
                ctx.strokeStyle = COLOR_TETHER; ctx.shadowColor = COLOR_TETHER; ctx.shadowBlur = 10; ctx.lineWidth = 2;
                ctx.scale(this.scale, this.scale);
                ctx.beginPath(); ctx.arc(0, 0, 12, 0, Math.PI * 2); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(-6, -6); ctx.lineTo(6, 6); ctx.moveTo(6, -6); ctx.lineTo(-6, 6); ctx.stroke();
                ctx.scale(1/this.scale, 1/this.scale);
                drawHpBar(ctx, this.hp, this.maxHp, 30*this.scale, this.scale);
                ctx.restore();
            }
        }

        class Tornado {
            constructor(x, y, tier = 1) {
                this.x = x; this.y = y; this.tier = tier;
                this.scale = tier === TIER_LARGE ? 3.75 : (tier === TIER_MED ? 3 : 2);
                this.hp = tier * 3; this.maxHp = this.hp;
                this.size = 15 * this.scale;
                this.vx = (Math.random() - 0.5) * 2; this.vy = (Math.random() - 0.5) * 2;
                this.state = 0; this.timer = 0; this.alpha = 1; this.spinAngle = 0;
            }
            update(player) {
                this.spinAngle += 0.1;
                if(this.x < -30) this.x = canvas.width + 30; if(this.x > canvas.width+30) this.x = -30;
                if(this.y < -30) this.y = canvas.height + 30; if(this.y > canvas.height+30) this.y = -30;
                if (this.state === 0) { 
                    this.x += this.vx; this.y += this.vy; this.timer++;
                    if (this.timer > 300) { this.state = 1; this.timer = 0; }
                } else if (this.state === 1) { 
                    this.alpha -= 0.05;
                    if (this.alpha <= 0) { this.alpha = 0; this.state = 2; this.timer = 0; }
                } else if (this.state === 2) { 
                    this.timer++;
                    if (this.timer > 60) { 
                        this.state = 3; this.timer = 0;
                        if (player) {
                            const dist = 40 + Math.random() * 30; const dir = Math.floor(Math.random() * 4);
                            if (dir === 0) { this.x = player.x; this.y = player.y - dist; }
                            else if (dir === 1) { this.x = player.x; this.y = player.y + dist; }
                            else if (dir === 2) { this.x = player.x - dist; this.y = player.y; }
                            else { this.x = player.x + dist; this.y = player.y; }
                        }
                    }
                } else if (this.state === 3) { 
                    this.alpha += 0.05;
                    if (this.alpha >= 1) { this.alpha = 1; this.state = 0; this.timer = 0; }
                }
            }
            takeDamage(amount) { if (this.state === 2) return false; this.hp -= amount; return this.hp <= 0; }
            draw(ctx) {
                if (this.alpha <= 0.01) return;
                ctx.save(); ctx.translate(this.x, this.y); ctx.globalAlpha = this.alpha;
                ctx.strokeStyle = COLOR_TORNADO; ctx.shadowColor = COLOR_TORNADO; ctx.shadowBlur = 10; ctx.lineWidth = 2;
                const sizes = [this.size * 0.8, this.size, this.size * 1.2];
                for(let i=0; i<3; i++) {
                    ctx.save(); ctx.rotate(this.spinAngle * (1 + i*0.5));
                    const s = sizes[i]; ctx.strokeRect(-s/2, -s/2, s, s); ctx.restore();
                }
                if (this.state === 0) drawHpBar(ctx, this.hp, this.maxHp, 30*this.scale, this.scale);
                ctx.restore();
            }
        }

        class Reflector {
            constructor(x, y, tier = 1) {
                this.x = x; this.y = y; this.tier = tier;
                this.scale = tier === TIER_LARGE ? 2 : (tier === TIER_MED ? 1.5 : 1);
                this.hp = tier * 4; this.maxHp = this.hp; 
                this.size = 20 * this.scale;
                this.vx = (Math.random() - 0.5) * 0.5; this.vy = (Math.random() - 0.5) * 0.5; this.angle = 0;
            }
            update() {
                this.x += this.vx; this.y += this.vy; this.angle += 0.01;
                if(this.x < -40) this.x = canvas.width + 40; if(this.x > canvas.width+40) this.x = -40;
                if(this.y < -40) this.y = canvas.height + 40; if(this.y > canvas.height+40) this.y = -40;
            }
            takeDamage(amount) {
                this.hp -= amount;
                if (player) {
                    const angle = Math.atan2(player.y - this.y, player.x - this.x);
                    bullets.push(new Bullet(this.x, this.y, angle, 'enemy'));
                }
                return this.hp <= 0;
            }
            draw(ctx) {
                ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle);
                ctx.strokeStyle = COLOR_REFLECTOR; ctx.shadowColor = COLOR_REFLECTOR; ctx.shadowBlur = 10; ctx.lineWidth = 3;
                ctx.scale(this.scale, this.scale);
                ctx.beginPath();
                for(let i=0; i<6; i++) { const a = i/6 * Math.PI*2; ctx.lineTo(Math.cos(a)*20, Math.sin(a)*20); }
                ctx.closePath(); ctx.stroke();
                ctx.fillStyle = 'rgba(255,255,255,0.1)'; ctx.fill();
                ctx.scale(1/this.scale, 1/this.scale); ctx.rotate(-this.angle);
                drawHpBar(ctx, this.hp, this.maxHp, 35*this.scale, this.scale);
                ctx.restore();
            }
        }

        class Trailblazer {
            constructor(x, y, tier = 1) {
                this.x = x; this.y = y; this.tier = tier;
                this.scale = tier === TIER_LARGE ? 2 : (tier === TIER_MED ? 1.5 : 1);
                this.hp = tier * 2; this.maxHp = this.hp;
                this.size = 15 * this.scale;
                this.speed = 3 + Math.random();
                const angle = Math.random() * Math.PI * 2;
                this.vx = Math.cos(angle) * this.speed; this.vy = Math.sin(angle) * this.speed;
                this.angle = angle; this.trail = []; this.trailTimer = 0;
            }
            update() {
                this.x += this.vx; this.y += this.vy;
                let wrapped = false;
                if(this.x < -this.size) { this.x = canvas.width + this.size; wrapped = true; }
                else if(this.x > canvas.width + this.size) { this.x = -this.size; wrapped = true; }
                if(this.y < -this.size) { this.y = canvas.height + this.size; wrapped = true; }
                else if(this.y > canvas.height + this.size) { this.y = -this.size; wrapped = true; }
                if (wrapped) this.trail = [];
                this.trailTimer++;
                if (this.trailTimer > 5) { this.trail.push({x: this.x, y: this.y, life: 300}); this.trailTimer = 0; }
                for(let i=this.trail.length-1; i>=0; i--) { this.trail[i].life--; if(this.trail[i].life <= 0) this.trail.splice(i, 1); }
            }
            takeDamage(amount) { this.hp -= amount; return this.hp <= 0; }
            draw(ctx) {
                ctx.strokeStyle = COLOR_TRAIL; ctx.lineWidth = 2; ctx.shadowColor = COLOR_TRAIL; ctx.shadowBlur = 5;
                ctx.beginPath();
                if (this.trail.length > 0) {
                    ctx.moveTo(this.trail[0].x, this.trail[0].y);
                    for(let i=1; i<this.trail.length; i++) ctx.lineTo(this.trail[i].x, this.trail[i].y);
                    ctx.lineTo(this.x, this.y);
                }
                ctx.stroke();
                ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle);
                ctx.strokeStyle = '#fff'; ctx.shadowColor = COLOR_TRAIL; ctx.shadowBlur = 10;
                ctx.scale(this.scale, this.scale);
                ctx.beginPath(); ctx.moveTo(15, 0); ctx.lineTo(-10, 10); ctx.lineTo(-5, 0); ctx.lineTo(-10, -10); ctx.closePath(); ctx.stroke();
                ctx.scale(1/this.scale, 1/this.scale);
                drawHpBar(ctx, this.hp, this.maxHp, 30*this.scale, this.scale, -this.angle);
                ctx.restore();
            }
        }

        class Orbital {
            constructor(x, y, tier = 1) {
                this.x = x; this.y = y; this.tier = tier;
                this.scale = tier === TIER_LARGE ? 2 : (tier === TIER_MED ? 1.5 : 1);
                this.hp = tier * 3; this.maxHp = this.hp;
                this.size = 15 * this.scale;
                this.vx = 0; this.vy = 0; this.orbAngle = 0; this.orbDist = 40 * this.scale; this.orbSize = 8 * this.scale;
            }
            update(player) {
                if(player) {
                    const dx = player.x - this.x; const dy = player.y - this.y;
                    const d = Math.sqrt(dx*dx + dy*dy);
                    if (d > 0) { this.vx += (dx/d) * 0.05; this.vy += (dy/d) * 0.05; }
                }
                this.x += this.vx; this.y += this.vy;
                const s = Math.sqrt(this.vx**2 + this.vy**2);
                if (s > 2) { this.vx *= 0.95; this.vy *= 0.95; }
                this.orbAngle += 0.1;
                if(this.x < -50) this.x = canvas.width+50; if(this.x > canvas.width+50) this.x = -50;
                if(this.y < -50) this.y = canvas.height+50; if(this.y > canvas.height+50) this.y = -50;
            }
            takeDamage(amount) { this.hp -= amount; return this.hp <= 0; }
            draw(ctx) {
                ctx.save(); ctx.translate(this.x, this.y);
                ctx.strokeStyle = COLOR_ORBITAL_CORE; ctx.shadowColor = COLOR_ORBITAL_CORE; ctx.shadowBlur = 10;
                ctx.scale(this.scale, this.scale);
                ctx.beginPath(); ctx.arc(0,0,15,0,Math.PI*2); ctx.stroke();
                ctx.fillStyle = COLOR_ORBITAL_SHIELD; ctx.shadowColor = COLOR_ORBITAL_SHIELD;
                for(let i=0; i<3; i++) {
                    const a = this.orbAngle + (i/3)*Math.PI*2;
                    const ox = Math.cos(a) * 40; const oy = Math.sin(a) * 40;
                    ctx.beginPath(); ctx.arc(ox, oy, 8, 0, Math.PI*2); ctx.fill();
                }
                ctx.scale(1/this.scale, 1/this.scale);
                drawHpBar(ctx, this.hp, this.maxHp, 50*this.scale, this.scale);
                ctx.restore();
            }
        }

        class Prism {
            constructor(x, y, tier = 1) {
                this.x = x; this.y = y; this.tier = tier;
                this.scale = tier === TIER_LARGE ? 2 : (tier === TIER_MED ? 1.5 : 1);
                this.hp = tier * 10; this.maxHp = this.hp;
                this.size = 25 * this.scale;
                this.angle = 0;
                this.vx = (Math.random()-0.5)*0.5; this.vy = (Math.random()-0.5)*0.5;
            }
            update() {
                this.x += this.vx; this.y += this.vy; this.angle += 0.02;
                if(this.x < -this.size) this.x = canvas.width + this.size; else if(this.x > canvas.width + this.size) this.x = -this.size;
                if(this.y < -this.size) this.y = canvas.height + this.size; else if(this.y > canvas.height + this.size) this.y = -this.size;
            }
            takeDamage(amount) { this.hp -= amount; return this.hp <= 0; }
            draw(ctx) {
                ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle);
                ctx.strokeStyle = COLOR_PRISM; ctx.lineWidth = 4; ctx.shadowColor = COLOR_PRISM; ctx.shadowBlur = 20;
                ctx.beginPath(); ctx.moveTo(0, -this.size); ctx.lineTo(0, -2000); ctx.stroke();
                ctx.lineWidth = 2; ctx.shadowBlur = 10;
                ctx.scale(this.scale, this.scale);
                ctx.beginPath(); ctx.moveTo(0, -25); ctx.lineTo(20, 20); ctx.lineTo(-20, 20); ctx.closePath(); ctx.stroke();
                ctx.scale(1/this.scale, 1/this.scale);
                ctx.rotate(-this.angle);
                drawHpBar(ctx, this.hp, this.maxHp, 40*this.scale, this.scale);
                ctx.restore();
            }
        }

        class Repulsor {
            constructor(x, y, tier = 1) {
                this.x = x; this.y = y; this.tier = tier;
                this.scale = tier === TIER_LARGE ? 2 : (tier === TIER_MED ? 1.5 : 1);
                this.hp = tier * 3; this.maxHp = this.hp;
                this.size = 25 * this.scale;
                this.pushRadius = 250 * this.scale;
                this.pushForce = 0.15 * this.scale;
                this.vx = (Math.random()-0.5)*0.5; this.vy = (Math.random()-0.5)*0.5;
            }
            update() {
                this.x += this.vx; this.y += this.vy;
                if(this.x < -this.size) this.x = canvas.width + this.size; else if(this.x > canvas.width + this.size) this.x = -this.size;
                if(this.y < -this.size) this.y = canvas.height + this.size; else if(this.y > canvas.height + this.size) this.y = -this.size;
            }
            takeDamage(amount) { this.hp -= amount; return this.hp <= 0; }
            draw(ctx) {
                ctx.save(); ctx.translate(this.x, this.y);
                ctx.strokeStyle = COLOR_REPULSOR; ctx.shadowColor = COLOR_REPULSOR; ctx.shadowBlur = 15;
                ctx.scale(this.scale, this.scale);
                const r = 25 + Math.sin(Date.now()/100) * 5;
                ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.stroke();
                ctx.beginPath(); ctx.arc(0,0,10,0,Math.PI*2); ctx.stroke();
                ctx.scale(1/this.scale, 1/this.scale);
                drawHpBar(ctx, this.hp, this.maxHp, 40*this.scale, this.scale);
                ctx.restore();
            }
        }

        // --- World 4 Enemies ---

        class StaticBeetle {
            constructor(x, y, tier = TIER_SMALL) {
                this.x = x; this.y = y; this.tier = tier;
                this.scale = tier === TIER_LARGE ? 1.8 : (tier === TIER_MED ? 1.4 : 1.1);
                this.hp = tier === TIER_LARGE ? 14 : (tier === TIER_MED ? 10 : 6);
                this.maxHp = this.hp;
                this.size = 22 * this.scale;
                this.vx = 0; this.vy = 0;
                this.angle = 0;
                this.turnRate = 0.045;
                this.maxSpeed = 2.2 + tier * 0.7;
                this.accel = 0.06 + tier * 0.01;
                this.pincerSpread = 0.55;
            }
            update(player) {
                if (player) {
                    const target = Math.atan2(player.y - this.y, player.x - this.x);
                    let diff = target - this.angle;
                    while (diff < -Math.PI) diff += Math.PI * 2;
                    while (diff > Math.PI) diff -= Math.PI * 2;
                    this.angle += Math.sign(diff) * Math.min(Math.abs(diff), this.turnRate);

                    this.vx += Math.cos(this.angle) * this.accel;
                    this.vy += Math.sin(this.angle) * this.accel;
                    const s = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                    if (s > this.maxSpeed) { this.vx = (this.vx / s) * this.maxSpeed; this.vy = (this.vy / s) * this.maxSpeed; }
                }
                this.x += this.vx; this.y += this.vy;
                if (this.x < -40) this.x = canvas.width + 40; if (this.x > canvas.width + 40) this.x = -40;
                if (this.y < -40) this.y = canvas.height + 40; if (this.y > canvas.height + 40) this.y = -40;
            }
            getArcTips() {
                const tipDist = this.size * 1.15;
                const a1 = this.angle - this.pincerSpread;
                const a2 = this.angle + this.pincerSpread;
                const ax = this.x + Math.cos(a1) * tipDist;
                const ay = this.y + Math.sin(a1) * tipDist;
                const bx = this.x + Math.cos(a2) * tipDist;
                const by = this.y + Math.sin(a2) * tipDist;
                return { ax, ay, bx, by };
            }
            takeDamage(amount) { this.hp -= amount; return this.hp <= 0; }
            draw(ctx) {
                ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle);
                ctx.strokeStyle = '#ff0'; ctx.shadowColor = '#ff0'; ctx.shadowBlur = 15; ctx.lineWidth = 3;
                // Body
                ctx.beginPath();
                ctx.rect(-this.size, -this.size * 0.7, this.size * 2, this.size * 1.4);
                ctx.stroke();
                ctx.globalAlpha = 0.15; ctx.fillStyle = '#ff0'; ctx.fillRect(-this.size, -this.size * 0.7, this.size * 2, this.size * 1.4);
                ctx.globalAlpha = 1;

                // Pincers
                ctx.beginPath();
                ctx.moveTo(this.size * 0.6, -this.size * 0.35);
                ctx.lineTo(this.size * 1.2, -this.size * 0.7);
                ctx.moveTo(this.size * 0.6, this.size * 0.35);
                ctx.lineTo(this.size * 1.2, this.size * 0.7);
                ctx.stroke();

                // Electric arc between pincer tips (simple line)
                ctx.strokeStyle = '#b0f'; ctx.shadowColor = '#b0f'; ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(this.size * 1.2, -this.size * 0.7);
                ctx.lineTo(this.size * 1.2, this.size * 0.7);
                ctx.stroke();

                ctx.restore();
                drawHpBar(ctx, this.hp, this.maxHp, this.size + 18, this.scale, 0, this.x, this.y);
            }
        }

        class PhaseMantis {
            constructor(x, y, tier = TIER_SMALL) {
                this.x = x; this.y = y; this.tier = tier;
                this.scale = tier === TIER_LARGE ? 1.5 : (tier === TIER_MED ? 1.2 : 1.0);
                this.hp = tier === TIER_LARGE ? 6 : (tier === TIER_MED ? 4 : 3);
                this.maxHp = this.hp;
                this.size = 14 * this.scale;
                this.vx = 0; this.vy = 0;
                this.visible = false;
                this.timer = Math.floor(Math.random() * 60);
            }
            update(player) {
                this.timer++;
                if (!player) return;

                if (!this.visible) {
                    // Invisible / invulnerable for ~2 seconds
                    if (this.timer > 120) {
                        const pvx = player.vx || 0; const pvy = player.vy || 0;
                        const speed = Math.sqrt(pvx * pvx + pvy * pvy);
                        let fx = Math.cos(player.angle); let fy = Math.sin(player.angle);
                        if (speed > 0.2) { fx = pvx / speed; fy = pvy / speed; }
                        const tx = player.x + fx * 180;
                        const ty = player.y + fy * 180;
                        this.x = tx + (Math.random() - 0.5) * 60;
                        this.y = ty + (Math.random() - 0.5) * 60;
                        this.visible = true;
                        this.timer = 0;
                        playSound('enemyShoot');
                    }
                } else {
                    // Visible strike window
                    if (this.timer < 25) {
                        const angle = Math.atan2(player.y - this.y, player.x - this.x);
                        const s = 5.5 + this.tier;
                        this.vx = Math.cos(angle) * s;
                        this.vy = Math.sin(angle) * s;
                    } else {
                        this.vx *= 0.92; this.vy *= 0.92;
                    }
                    this.x += this.vx; this.y += this.vy;
                    if (this.timer > 60) { this.visible = false; this.timer = 0; this.vx = 0; this.vy = 0; }
                }

                if (this.x < -40) this.x = canvas.width + 40; if (this.x > canvas.width + 40) this.x = -40;
                if (this.y < -40) this.y = canvas.height + 40; if (this.y > canvas.height + 40) this.y = -40;
            }
            takeDamage(amount) {
                if (!this.visible) return false;
                this.hp -= amount;
                return this.hp <= 0;
            }
            draw(ctx) {
                if (!this.visible) return;
                ctx.save(); ctx.translate(this.x, this.y);
                ctx.strokeStyle = '#fff'; ctx.shadowColor = '#fff'; ctx.shadowBlur = 12; ctx.lineWidth = 2;
                ctx.globalAlpha = 0.75;
                ctx.beginPath();
                ctx.moveTo(0, -this.size);
                ctx.lineTo(this.size, 0);
                ctx.lineTo(0, this.size);
                ctx.lineTo(-this.size, 0);
                ctx.closePath();
                ctx.stroke();
                ctx.globalAlpha = 1;
                ctx.restore();
                drawHpBar(ctx, this.hp, this.maxHp, this.size + 16, this.scale, 0, this.x, this.y);
            }
        }

        class SniperMosquito {
            constructor(x, y, tier = TIER_SMALL) {
                this.x = x; this.y = y; this.tier = tier;
                this.scale = tier === TIER_LARGE ? 1.3 : (tier === TIER_MED ? 1.1 : 0.95);
                this.hp = tier === TIER_LARGE ? 6 : (tier === TIER_MED ? 4 : 3);
                this.maxHp = this.hp;
                this.size = 10 * this.scale;
                this.vx = 0; this.vy = 0;

                this.aimTimer = 0;
                this.cooldown = 90 + Math.floor(Math.random() * 60);
                this.beamTimer = 0;
                this.aimAngle = 0;
            }
            update(player) {
                if (player) {
                    const dx = this.x - player.x; const dy = this.y - player.y;
                    const d = Math.sqrt(dx * dx + dy * dy) || 1;

                    // Keep distance: flee when close
                    if (d < 500) {
                        this.vx += (dx / d) * 0.12;
                        this.vy += (dy / d) * 0.12;
                    }

                    // Drift toward screen edges
                    const margin = 60;
                    const targetX = this.x < canvas.width / 2 ? margin : canvas.width - margin;
                    const targetY = this.y < canvas.height / 2 ? margin : canvas.height - margin;
                    this.vx += (targetX - this.x) * 0.0003;
                    this.vy += (targetY - this.y) * 0.0003;

                    const sp = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                    const maxSp = 2.4 + this.tier * 0.3;
                    if (sp > maxSp) { this.vx = (this.vx / sp) * maxSp; this.vy = (this.vy / sp) * maxSp; }

                    this.x += this.vx; this.y += this.vy;
                    this.vx *= 0.98; this.vy *= 0.98;

                    if (this.cooldown > 0) {
                        this.cooldown--;
                    } else {
                        this.aimTimer++;
                        this.aimAngle = Math.atan2(player.y - this.y, player.x - this.x);
                        if (this.aimTimer >= 90) {
                            // Fire instant-hit beam after 1.5s aim
                            const x2 = this.x + Math.cos(this.aimAngle) * 2000;
                            const y2 = this.y + Math.sin(this.aimAngle) * 2000;
                            const dSeg = pointToSegmentDistance(player.x, player.y, this.x, this.y, x2, y2);
                            if (dSeg < PLAYER_SIZE + 4) {
                                if (takeDamage(25)) return;
                            }
                            this.beamTimer = 10;
                            this.aimTimer = 0;
                            this.cooldown = 180;
                            playSound('enemyShoot');
                        }
                    }
                }

                if (this.beamTimer > 0) this.beamTimer--;

                // Clamp inside screen (snipers hug edges)
                const pad = 30;
                this.x = Math.max(pad, Math.min(canvas.width - pad, this.x));
                this.y = Math.max(pad, Math.min(canvas.height - pad, this.y));
            }
            takeDamage(amount) { this.hp -= amount; return this.hp <= 0; }
            draw(ctx) {
                ctx.save(); ctx.translate(this.x, this.y);
                ctx.strokeStyle = '#f00'; ctx.shadowColor = '#f00'; ctx.shadowBlur = 10; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.arc(0, 0, this.size, 0, Math.PI * 2); ctx.stroke();
                // Proboscis
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(Math.cos(this.aimAngle) * this.size * 2.2, Math.sin(this.aimAngle) * this.size * 2.2);
                ctx.stroke();
                ctx.restore();

                if (this.aimTimer > 0) {
                    const x2 = this.x + Math.cos(this.aimAngle) * 2000;
                    const y2 = this.y + Math.sin(this.aimAngle) * 2000;
                    ctx.save();
                    ctx.strokeStyle = 'rgba(255,0,0,0.35)';
                    ctx.lineWidth = 2;
                    ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(x2, y2); ctx.stroke();
                    ctx.restore();
                }
                if (this.beamTimer > 0) {
                    const x2 = this.x + Math.cos(this.aimAngle) * 2000;
                    const y2 = this.y + Math.sin(this.aimAngle) * 2000;
                    ctx.save();
                    ctx.strokeStyle = 'rgba(255,0,0,0.8)';
                    ctx.lineWidth = 6;
                    ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(x2, y2); ctx.stroke();
                    ctx.restore();
                }
                drawHpBar(ctx, this.hp, this.maxHp, this.size + 16, this.scale, 0, this.x, this.y);
            }
        }

        class ClusterRoach {
            constructor(x, y, tier = TIER_SMALL) {
                this.x = x; this.y = y; this.tier = tier;
                this.scale = tier === TIER_LARGE ? 2.0 : (tier === TIER_MED ? 1.6 : 1.25);
                this.hp = tier === TIER_LARGE ? 26 : (tier === TIER_MED ? 20 : 14);
                this.maxHp = this.hp;
                this.size = 26 * this.scale;
                this.vx = (Math.random() - 0.5) * 3;
                this.vy = (Math.random() - 0.5) * 3;
                this.changeTimer = 0;
            }
            update(player) {
                this.changeTimer--;
                if (this.changeTimer <= 0) {
                    this.changeTimer = 25 + Math.floor(Math.random() * 25);
                    const a = Math.random() * Math.PI * 2;
                    const s = 1.2 + this.tier * 0.8;
                    this.vx = Math.cos(a) * s;
                    this.vy = Math.sin(a) * s;
                    if (player && Math.random() > 0.5) {
                        const pa = Math.atan2(player.y - this.y, player.x - this.x);
                        this.vx += Math.cos(pa) * 0.8;
                        this.vy += Math.sin(pa) * 0.8;
                    }
                }
                this.x += this.vx; this.y += this.vy;
                if (this.x < -50) this.x = canvas.width + 50; if (this.x > canvas.width + 50) this.x = -50;
                if (this.y < -50) this.y = canvas.height + 50; if (this.y > canvas.height + 50) this.y = -50;
            }
            takeDamage(amount) { this.hp -= amount; return this.hp <= 0; }
            draw(ctx) {
                ctx.save(); ctx.translate(this.x, this.y);
                ctx.strokeStyle = '#0f0'; ctx.shadowColor = '#0f0'; ctx.shadowBlur = 10; ctx.lineWidth = 2;
                // Flat segmented body
                for (let i = -2; i <= 2; i++) {
                    ctx.strokeRect(-this.size * 0.9 + i * (this.size * 0.35), -this.size * 0.35, this.size * 0.32, this.size * 0.7);
                }
                ctx.restore();
                drawHpBar(ctx, this.hp, this.maxHp, this.size + 18, this.scale, 0, this.x, this.y);
            }
        }

        class RoachMite {
            constructor(x, y, tier = TIER_SMALL) {
                this.x = x; this.y = y; this.tier = tier;
                this.hp = 1; this.maxHp = this.hp;
                this.size = 8 + tier * 2;
                this.vx = 0; this.vy = 0;
            }
            update(player) {
                if (!player) return;
                const a = Math.atan2(player.y - this.y, player.x - this.x);
                const s = 4.5 + this.tier * 0.8;
                this.vx = Math.cos(a) * s;
                this.vy = Math.sin(a) * s;
                this.x += this.vx; this.y += this.vy;
                if (this.x < -40) this.x = canvas.width + 40; if (this.x > canvas.width + 40) this.x = -40;
                if (this.y < -40) this.y = canvas.height + 40; if (this.y > canvas.height + 40) this.y = -40;
            }
            takeDamage(amount) { this.hp -= amount; return this.hp <= 0; }
            draw(ctx) {
                ctx.save(); ctx.translate(this.x, this.y);
                ctx.fillStyle = '#0f0'; ctx.shadowColor = '#0f0'; ctx.shadowBlur = 8;
                ctx.beginPath(); ctx.arc(0, 0, this.size, 0, Math.PI * 2); ctx.fill();
                ctx.restore();
            }
        }

        class SiphonFly {
            constructor(x, y, tier = TIER_SMALL) {
                this.x = x; this.y = y; this.tier = tier;
                this.scale = tier === TIER_LARGE ? 1.1 : (tier === TIER_MED ? 0.95 : 0.8);
                this.hp = tier === TIER_LARGE ? 3 : (tier === TIER_MED ? 2 : 1);
                this.maxHp = this.hp;
                this.size = 7 * this.scale;
                this.orbitAngle = Math.random() * Math.PI * 2;
                this.orbitDist = 55 + Math.random() * 25;
                this.drainCooldown = 0;
            }
            update(player) {
                if (!player) return;
                if (this.drainCooldown > 0) this.drainCooldown--;
                this.orbitAngle += 0.12 + this.tier * 0.02;
                const tx = player.x + Math.cos(this.orbitAngle) * this.orbitDist;
                const ty = player.y + Math.sin(this.orbitAngle) * this.orbitDist;
                this.x += (tx - this.x) * 0.12;
                this.y += (ty - this.y) * 0.12;
            }
            takeDamage(amount) { this.hp -= amount; return this.hp <= 0; }
            draw(ctx) {
                ctx.save(); ctx.translate(this.x, this.y);
                ctx.strokeStyle = '#d0f'; ctx.shadowColor = '#d0f'; ctx.shadowBlur = 12; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.arc(0, 0, this.size, 0, Math.PI * 2); ctx.stroke();
                ctx.restore();
            }
        }

        class WebNode {
            constructor(x, y, groupId, prevId = null) {
                this.id = nextWebNodeId++;
                this.x = x; this.y = y;
                this.groupId = groupId;
                this.prevId = prevId;
                this.hp = 2; this.maxHp = this.hp;
                this.size = 12;
            }
            takeDamage(amount) { this.hp -= amount; return this.hp <= 0; }
            draw(ctx) {
                ctx.save(); ctx.translate(this.x, this.y);
                ctx.strokeStyle = '#0ff'; ctx.shadowColor = '#0ff'; ctx.shadowBlur = 10; ctx.lineWidth = 2;
                ctx.strokeRect(-this.size/2, -this.size/2, this.size, this.size);
                ctx.restore();
            }
        }

        class WebWeaver {
            constructor(x, y, tier = TIER_SMALL) {
                this.x = x; this.y = y; this.tier = tier;
                this.scale = tier === TIER_LARGE ? 1.7 : (tier === TIER_MED ? 1.35 : 1.1);
                this.hp = tier === TIER_LARGE ? 10 : (tier === TIER_MED ? 7 : 5);
                this.maxHp = this.hp;
                this.size = 18 * this.scale;
                this.vx = (Math.random() - 0.5) * 1.6;
                this.vy = (Math.random() - 0.5) * 1.6;
                this.webGroupId = nextWebGroupId++;
                this.webCenterX = x;
                this.webCenterY = y;
                this.dropTimer = 0;
                this.lastNodeId = null;
                this.nodesDropped = 0;
                this.maxNodes = 14 + this.tier * 5;

                this.walkT = Math.random() * 1000;
                this.legPhase = Array.from({ length: 6 }, () => Math.random() * Math.PI * 2);
                this.footPhase = Array.from({ length: 6 }, () => Math.random() * Math.PI * 2);
            }
            update(player) {
                // Slow creep
                this.x += this.vx; this.y += this.vy;
                if (Math.random() < 0.01) { this.vx = (Math.random() - 0.5) * 0.9; this.vy = (Math.random() - 0.5) * 0.9; }

                const speed = Math.hypot(this.vx, this.vy);
                this.walkT += 0.06 + Math.min(0.10, speed * 0.05);

                // Keep fully on-screen and bounce off edges
                const pad = this.size + 4;
                if (this.x < pad) { this.x = pad; if (this.vx < 0) this.vx = -this.vx; }
                if (this.x > canvas.width - pad) { this.x = canvas.width - pad; if (this.vx > 0) this.vx = -this.vx; }
                if (this.y < pad) { this.y = pad; if (this.vy < 0) this.vy = -this.vy; }
                if (this.y > canvas.height - pad) { this.y = canvas.height - pad; if (this.vy > 0) this.vy = -this.vy; }
                this.dropTimer++;
                // Keep dropping nodes if we're at least 4 under the max.
                // (Nodes can be destroyed; nodesDropped counts historical drops, so use current live nodes.)
                let currentNodes = 0;
                for (let i = 0; i < webNodes.length; i++) if (webNodes[i].groupId === this.webGroupId) currentNodes++;
                const dropThreshold = Math.max(0, this.maxNodes - 4);

                if (this.dropTimer > 30 && currentNodes <= dropThreshold) {
                    this.dropTimer = 0;
                    // Drop nodes clustered around a fixed center (not a vertical chain / not all over the screen)
                    const pad = this.size + 6;
                    const radius = 120;
                    const minStep = 70;

                    let prev = null;
                    if (this.lastNodeId != null) {
                        for (let i = 0; i < webNodes.length; i++) {
                            if (webNodes[i].id === this.lastNodeId) { prev = webNodes[i]; break; }
                        }
                    }

                    // Keep the cluster center on-screen.
                    const cx = Math.max(pad, Math.min(canvas.width - pad, this.webCenterX));
                    const cy = Math.max(pad, Math.min(canvas.height - pad, this.webCenterY));

                    let nx = cx;
                    let ny = cy;
                    for (let attempt = 0; attempt < 12; attempt++) {
                        const a = Math.random() * Math.PI * 2;
                        const r = radius * Math.sqrt(Math.random());
                        const tx = Math.max(pad, Math.min(canvas.width - pad, cx + Math.cos(a) * r));
                        const ty = Math.max(pad, Math.min(canvas.height - pad, cy + Math.sin(a) * r));
                        if (!prev || Math.hypot(tx - prev.x, ty - prev.y) >= minStep) { nx = tx; ny = ty; break; }
                        nx = tx; ny = ty;
                    }

                    const node = new WebNode(nx, ny, this.webGroupId, this.lastNodeId);
                    this.lastNodeId = node.id;
                    this.nodesDropped++;
                    webNodes.push(node);
                    playSound('enemyShoot');
                }
            }
            takeDamage(amount) { this.hp -= amount; return this.hp <= 0; }
            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.strokeStyle = '#0ff';
                ctx.shadowColor = '#0ff';
                ctx.shadowBlur = 15;
                ctx.lineWidth = 2;

                const R = this.size;
                const bodyR = R * 0.95;

                // Precompute hex vertices (pointy top/bottom)
                const verts = [];
                for (let i = 0; i < 6; i++) {
                    const a = (-Math.PI / 2) + (i * Math.PI * 2) / 6;
                    verts.push({ x: Math.cos(a) * bodyR, y: Math.sin(a) * bodyR });
                }

                // Legs: one per vertex, two segments with a simple walking animation
                const longLen = R * 0.9;
                const shortLen = R * 0.55;
                const kneeWobble = R * 0.12;
                const footRadius = R * 0.22;

                for (let i = 0; i < 6; i++) {
                    const v = verts[i];
                    const len = Math.hypot(v.x, v.y) || 1;
                    const dx = v.x / len;
                    const dy = v.y / len;
                    const px = -dy;
                    const py = dx;

                    const phase = this.legPhase[i];
                    const kneeOffset = Math.sin(this.walkT + phase);
                    const kneeX = v.x + dx * longLen + px * kneeWobble * kneeOffset;
                    const kneeY = v.y + dy * longLen + py * kneeWobble * kneeOffset;

                    const footPhase = this.footPhase[i];
                    const jitterX = Math.cos(this.walkT * 1.7 + footPhase) * footRadius;
                    const jitterY = Math.sin(this.walkT * 1.3 + footPhase) * footRadius;
                    const footX = kneeX + dx * shortLen + jitterX;
                    const footY = kneeY + dy * shortLen + jitterY;

                    ctx.beginPath();
                    ctx.moveTo(v.x, v.y);
                    ctx.lineTo(kneeX, kneeY);
                    ctx.lineTo(footX, footY);
                    ctx.stroke();
                }

                // Body: hexagon
                ctx.beginPath();
                ctx.moveTo(verts[0].x, verts[0].y);
                for (let i = 1; i < 6; i++) ctx.lineTo(verts[i].x, verts[i].y);
                ctx.closePath();
                ctx.stroke();

                // Eyes: 3 circles in a triangle (two up, one down)
                ctx.save();
                ctx.shadowBlur = 0;
                const eyeR = Math.max(2.5, R * 0.10);
                const eyeTopY = -R * 0.25;
                const eyeTopX = R * 0.22;
                const eyeBottomY = R * 0.48;
                ctx.beginPath(); ctx.arc(-eyeTopX, eyeTopY, eyeR, 0, Math.PI * 2); ctx.stroke();
                ctx.beginPath(); ctx.arc(eyeTopX, eyeTopY, eyeR, 0, Math.PI * 2); ctx.stroke();
                ctx.beginPath(); ctx.arc(0, eyeBottomY, eyeR, 0, Math.PI * 2); ctx.stroke();
                ctx.restore();

                ctx.restore();
                drawHpBar(ctx, this.hp, this.maxHp, this.size + 18, this.scale, 0, this.x, this.y);
            }
        }

        class HawkShooter {
            constructor(x, y, tier = TIER_SMALL) {
                this.x = x; this.y = y; this.tier = tier;
                this.scale = tier === TIER_LARGE ? 1.8 : (tier === TIER_MED ? 1.45 : 1.15);
                this.hp = tier === TIER_LARGE ? 10 : (tier === TIER_MED ? 7 : 5);
                this.maxHp = this.hp;
                this.size = 16 * this.scale;
                this.vx = 0; this.vy = 0;
                this.state = 0; // 0 = flee (3s), 1 = shoot (1s)
                this.timer = 0;
                this.angle = 0;
            }
            update(player) {
                if (!player) return;
                this.timer++;
                const toward = Math.atan2(player.y - this.y, player.x - this.x);
                // Face the player while shooting (beak/body point toward player)
                // While fleeing, face away.
                this.angle = (this.state === 1) ? toward : (toward + Math.PI);
                if (this.state === 0) {
                    // Move away from the player for 3 seconds
                    const away = toward + Math.PI;
                    this.vx += Math.cos(away) * 0.08;
                    this.vy += Math.sin(away) * 0.08;
                    const s = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                    const maxS = 2.4 + this.tier * 0.3;
                    if (s > maxS) { this.vx = (this.vx / s) * maxS; this.vy = (this.vy / s) * maxS; }
                    this.x += this.vx; this.y += this.vy;
                    this.vx *= 0.98; this.vy *= 0.98;
                    if (this.timer > 180) { this.state = 1; this.timer = 0; this.vx = 0; this.vy = 0; }
                } else {
                    // Hold position and shoot for 1.5 seconds
                    if (this.timer % 10 === 0) this.shootAt(player);
                    if (this.timer > 120) { this.state = 0; this.timer = 0; }
                }

                // Wrap without parking the hawk off-screen (it can hold still while shooting)
                const m = 160;
                if (this.x < -m) this.x = canvas.width - m;
                if (this.x > canvas.width + m) this.x = m;
                if (this.y < -m) this.y = canvas.height - m;
                if (this.y > canvas.height + m) this.y = m;
            }
            shootAt(player) {
                const ang = Math.atan2(player.y - this.y, player.x - this.x);
                const perp = ang + Math.PI / 2;
                const wingOffset = this.size * 0.9;
                const leftX = this.x + Math.cos(perp) * wingOffset;
                const leftY = this.y + Math.sin(perp) * wingOffset;
                const rightX = this.x - Math.cos(perp) * wingOffset;
                const rightY = this.y - Math.sin(perp) * wingOffset;

                const sep = 6;
                // Two parallel bullets from each wing (4 total)
                bullets.push(new Bullet(leftX + Math.cos(perp) * sep, leftY + Math.sin(perp) * sep, ang, 'enemy'));
                bullets.push(new Bullet(leftX - Math.cos(perp) * sep, leftY - Math.sin(perp) * sep, ang, 'enemy'));
                bullets.push(new Bullet(rightX + Math.cos(perp) * sep, rightY + Math.sin(perp) * sep, ang, 'enemy'));
                bullets.push(new Bullet(rightX - Math.cos(perp) * sep, rightY - Math.sin(perp) * sep, ang, 'enemy'));
                playSound('enemyShoot');
            }
            takeDamage(amount) { this.hp -= amount; return this.hp <= 0; }
            draw(ctx) {
                ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle);
                ctx.strokeStyle = '#fa0'; ctx.shadowColor = '#fa0'; ctx.shadowBlur = 12; ctx.lineWidth = 2;

                const s = this.size;
                const bodyW = s * 0.85;
                const bodyBack = -s * 1.25;
                const bodyFront = s * 0.95;

                // Body (sleek oval/teardrop outline)
                ctx.beginPath();
                ctx.moveTo(bodyFront, 0);
                ctx.quadraticCurveTo(s * 0.35, -bodyW, bodyBack, -bodyW * 0.25);
                ctx.quadraticCurveTo(bodyBack - s * 0.35, 0, bodyBack, bodyW * 0.25);
                ctx.quadraticCurveTo(s * 0.35, bodyW, bodyFront, 0);
                ctx.stroke();

                // Tail (forked)
                ctx.beginPath();
                ctx.moveTo(bodyBack, 0);
                ctx.lineTo(bodyBack - s * 0.8, -s * 0.35);
                ctx.lineTo(bodyBack - s * 0.55, 0);
                ctx.lineTo(bodyBack - s * 0.8, s * 0.35);
                ctx.closePath();
                ctx.stroke();

                // Wings (two swept polygons). Bullets fire from the wing area; do NOT draw hardpoints.
                const wingBaseX = s * 0.15;
                const wingMidX = -s * 0.25;
                const wingTipX = -s * 1.55;
                const wingSpan = s * 1.55;
                const wingInset = s * 0.55;

                // Left wing (+y)
                ctx.beginPath();
                ctx.moveTo(wingBaseX, wingInset);
                ctx.lineTo(wingMidX, wingSpan);
                ctx.lineTo(wingTipX, wingSpan * 0.85);
                ctx.lineTo(-s * 0.85, wingInset * 0.85);
                ctx.closePath();
                ctx.stroke();

                // Right wing (-y)
                ctx.beginPath();
                ctx.moveTo(wingBaseX, -wingInset);
                ctx.lineTo(wingMidX, -wingSpan);
                ctx.lineTo(wingTipX, -wingSpan * 0.85);
                ctx.lineTo(-s * 0.85, -wingInset * 0.85);
                ctx.closePath();
                ctx.stroke();

                // Beak (points forward toward player while shooting)
                ctx.beginPath();
                ctx.moveTo(bodyFront - s * 0.15, -s * 0.22);
                ctx.lineTo(bodyFront + s * 0.75, 0);
                ctx.lineTo(bodyFront - s * 0.15, s * 0.22);
                ctx.closePath();
                ctx.stroke();

                // Small neck notch / body detail
                ctx.beginPath();
                ctx.moveTo(s * 0.55, -s * 0.22);
                ctx.lineTo(s * 0.35, 0);
                ctx.lineTo(s * 0.55, s * 0.22);
                ctx.stroke();

                ctx.restore();
                drawHpBar(ctx, this.hp, this.maxHp, this.size + 18, this.scale, 0, this.x, this.y);
            }
        }

        class Player {
            constructor() { this.hardReset(); }
            hardReset() {
                this.shotLevel = 1; this.shotTimer = 0;
                this.rateLevel = 0; this.rateTimer = 0;
                this.reverseTimer = 0;
                this.ultCharge = 0; this.ultActive = false; this.ultTimer = 0;
                this.slowTimer = 0;
                this.dampenTimer = 0; // 50% move + rotation slow
                this.gridLockTimer = 0; // 90% move + rotation slow
                this.respawn();
            }
            respawn() {
                this.x = canvas.width / 2; this.y = canvas.height / 2;
                this.vx = 0; this.vy = 0; this.angle = -Math.PI / 2;
                this.health = 100; this.armor = 0;
                this.invulnerable = 120; this.fireCooldown = 0;
                this.ultActive = false; this.ultTimer = 0;
                this.slowTimer = 0;
                this.dampenTimer = 0;
                this.gridLockTimer = 0;
                if (typeof player !== 'undefined') {
                    updateHealthUI(); updateUltUI();
                    let status = "";
                    if(this.shotLevel > 1) status += `MULTI-SHOT X${this.shotLevel} `;
                    if(this.rateLevel > 0) status += `RAPID X${this.rateLevel} `;
                    if(this.reverseTimer > 0) status += `REVERSE `;
                    document.getElementById('powerup-status').innerText = status;
                }
            }
            update() {
                // Status timers
                if (this.slowTimer > 0) this.slowTimer--;
                if (this.dampenTimer > 0) this.dampenTimer--;
                if (this.gridLockTimer > 0) this.gridLockTimer--;

                // Slow effect handling
                let effectiveAccel = ACCELERATION;
                let effectiveRot = ROTATION_SPEED;
                if (this.slowTimer > 0) { effectiveAccel *= 0.25; }
                if (this.dampenTimer > 0) { effectiveAccel *= 0.5; effectiveRot *= 0.5; }
                if (this.gridLockTimer > 0) { effectiveAccel *= 0.1; effectiveRot *= 0.1; }

                if (keys.a) this.angle -= effectiveRot;
                if (keys.d) this.angle += effectiveRot;
                
                if (keys.w) {
                    this.vx += Math.cos(this.angle) * effectiveAccel;
                    this.vy += Math.sin(this.angle) * effectiveAccel;
                    if (Math.random() > 0.5) {
                        const offsetX = this.x - Math.cos(this.angle) * PLAYER_SIZE;
                        const offsetY = this.y - Math.sin(this.angle) * PLAYER_SIZE;
                        particles.push(new Particle(offsetX, offsetY, '#0ff', 2, 2, 20));
                    }
                }
                this.vx *= FRICTION; this.vy *= FRICTION;
                this.x += this.vx; this.y += this.vy;
                if (this.x < 0) this.x = canvas.width; if (this.x > canvas.width) this.x = 0;
                if (this.y < 0) this.y = canvas.height; if (this.y > canvas.height) this.y = 0;

                if (this.shotTimer > 0) { this.shotTimer--; if (this.shotTimer <= 0) this.shotLevel = 1; }
                if (this.rateTimer > 0) { this.rateTimer--; if (this.rateTimer <= 0) this.rateLevel = 0; }
                if (this.reverseTimer > 0) { this.reverseTimer--; }

                // Ultimate Logic
                if (this.ultActive) {
                    this.ultTimer--;
                    if (this.ultTimer <= 0) { 
                        this.ultActive = false; 
                        this.ultCharge = 0; 
                    } else { 
                        shakeAmount = 2; 
                    }
                } else {
                    if (this.ultCharge < ULT_CHARGE_TIME) { this.ultCharge++; }
                    if (this.ultCharge >= ULT_CHARGE_TIME && keys.shift) {
                        this.ultActive = true; this.ultTimer = ULT_DURATION; playSound('laser');
                    }
                }
                updateUltUI();

                if (this.fireCooldown > 0) this.fireCooldown--;
                const wantsToFire = keys.space || gameState.autoFire;
                if (wantsToFire && this.fireCooldown <= 0 && !this.ultActive) this.shoot();
                if (this.invulnerable > 0) this.invulnerable--;
                
                let status = "";
                if(this.shotLevel > 1) status += `MULTI-SHOT X${this.shotLevel} `;
                if(this.rateLevel > 0) status += `RAPID X${this.rateLevel} `;
                if(this.reverseTimer > 0) status += `REVERSE `;
                document.getElementById('powerup-status').innerText = status;
            }
            shoot() {
                const fireDelay = Math.max(5, BASE_FIRE_RATE - (this.rateLevel * 2));
                const spawnBullets = (baseAngle) => {
                    const perpAngle = baseAngle + Math.PI / 2;
                    const px = Math.cos(perpAngle); const py = Math.sin(perpAngle);
                    const spacing = 10; 
                    for(let i=0; i<this.shotLevel; i++) {
                        const offset = (i - (this.shotLevel - 1) / 2) * spacing;
                        const bx = this.x + Math.cos(baseAngle) * PLAYER_SIZE + offset * px;
                        const by = this.y + Math.sin(baseAngle) * PLAYER_SIZE + offset * py;
                        bullets.push(new Bullet(bx, by, baseAngle));
                    }
                };
                spawnBullets(this.angle);
                if (this.reverseTimer > 0) spawnBullets(this.angle + Math.PI);
                this.vx -= Math.cos(this.angle) * BULLET_RECOIL;
                this.vy -= Math.sin(this.angle) * BULLET_RECOIL;
                this.fireCooldown = fireDelay;
                playSound('shoot');
            }
            draw(ctx) {
                if (this.invulnerable > 0 && Math.floor(Date.now() / 100) % 2 === 0) return;
                if (this.ultActive) {
                    const lx = this.x + Math.cos(this.angle) * PLAYER_SIZE;
                    const ly = this.y + Math.sin(this.angle) * PLAYER_SIZE;
                    const endX = lx + Math.cos(this.angle) * LASER_LENGTH;
                    const endY = ly + Math.sin(this.angle) * LASER_LENGTH;
                    ctx.save(); ctx.beginPath(); ctx.moveTo(lx, ly); ctx.lineTo(endX, endY);
                    ctx.strokeStyle = '#fff'; ctx.lineWidth = 10; ctx.shadowColor = COLOR_LASER; ctx.shadowBlur = 20; ctx.stroke();
                    ctx.strokeStyle = COLOR_LASER; ctx.lineWidth = LASER_WIDTH; ctx.globalAlpha = 0.5; ctx.stroke();
                    ctx.restore();
                }
                ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle);
                
                // Slowed Visual
                 if (this.slowTimer > 0 || this.dampenTimer > 0 || this.gridLockTimer > 0) {
                     ctx.strokeStyle = '#00f'; ctx.shadowColor = '#00f';
                } else {
                     ctx.strokeStyle = COLOR_PLAYER; ctx.shadowColor = COLOR_PLAYER;
                }
                
                ctx.lineWidth = 2; ctx.shadowBlur = 15;
                ctx.beginPath(); ctx.moveTo(PLAYER_SIZE, 0);
                ctx.lineTo(-PLAYER_SIZE/1.5, PLAYER_SIZE/1.5); ctx.lineTo(-PLAYER_SIZE/3, 0); ctx.lineTo(-PLAYER_SIZE/1.5, -PLAYER_SIZE/1.5);
                ctx.closePath(); ctx.stroke();
                ctx.fillStyle = '#fff'; ctx.fillRect(0, -1, 4, 2);
                if (this.armor > 0) {
                    ctx.beginPath(); ctx.arc(0, 0, PLAYER_SIZE + 5, 0, Math.PI * 2);
                    ctx.strokeStyle = '#ff0'; ctx.shadowColor = '#ff0';
                    ctx.globalAlpha = 0.5 + Math.sin(Date.now() / 100) * 0.2; ctx.stroke();
                }
                ctx.restore();
            }
        }

        // --- Game System ---

        let shakeAmount = 0;

        function init() {
            window.addEventListener('resize', resize);
            resize();
            window.addEventListener('keydown', e => {
                if (!gameState.running) return;
                if (e.key === 'w' || e.key === 'W' || e.key === 'ArrowUp') keys.w = true;
                if (e.key === 'a' || e.key === 'A' || e.key === 'ArrowLeft') keys.a = true;
                if (e.key === 'd' || e.key === 'D' || e.key === 'ArrowRight') keys.d = true;
                if (e.key === ' ') keys.space = true;
                if (e.key === 'Shift') keys.shift = true;
                if ((e.key === 'f' || e.key === 'F') && !e.repeat) {
                    gameState.autoFire = !gameState.autoFire;
                    if (player) createFloatingText(gameState.autoFire ? 'AUTO FIRE ON' : 'AUTO FIRE OFF', player.x, player.y);
                }
                if (e.key === 'p' || e.key === 'P') togglePause();
            });
            window.addEventListener('keyup', e => {
                if (e.key === 'w' || e.key === 'W' || e.key === 'ArrowUp') keys.w = false;
                if (e.key === 'a' || e.key === 'A' || e.key === 'ArrowLeft') keys.a = false;
                if (e.key === 'd' || e.key === 'D' || e.key === 'ArrowRight') keys.d = false;
                if (e.key === ' ') keys.space = false;
                if (e.key === 'Shift') keys.shift = false;
            });
            for(let i=0; i<200; i++) stars.push(new Star());
            player = new Player();
            
            // Initial UI Update for World
            document.getElementById('val-world').innerText = settings.world;

            // Loop starts immediately to render background, but game entities don't update until running
            loop();
        }

        function resize() {
            const maxWidth = 1200;
            canvas.width = Math.min(window.innerWidth, maxWidth);
            canvas.height = window.innerHeight;
        }

        function togglePause() {
            if (gameState.running && !gameState.gameOver) {
                gameState.paused = !gameState.paused;
            }
        }

        // Define UI update functions globally so Player class can access them
        function updateHealthUI() {
            if (!player) return;
            const healthFill = document.getElementById('health-fill');
            const armorFill = document.getElementById('armor-fill');
            if (healthFill) {
                healthFill.style.width = Math.max(0, player.health) + '%';
                healthFill.style.backgroundColor = player.health < 40 ? '#f00' : '#0ff';
            }
            if (armorFill) {
                armorFill.style.width = Math.max(0, player.armor) + '%';
            }
        }

        function updateUltUI() {
            if (!player) return;
            const pct = (player.ultCharge / ULT_CHARGE_TIME) * 100;
            const bar = document.getElementById('ultimate-fill');
            const text = document.getElementById('ultimate-text');
            
            if (bar) bar.style.width = pct + '%';
            
            if (bar && text) {
                if (player.ultActive) {
                    bar.style.backgroundColor = '#fff'; 
                    bar.style.boxShadow = '0 0 15px #fff';
                    text.style.color = '#fff';
                    text.innerText = "LASER ACTIVE";
                } else if (player.ultCharge >= ULT_CHARGE_TIME) {
                    const flash = (Math.floor(Date.now() / 200) % 2 === 0);
                    bar.style.backgroundColor = flash ? '#d0f' : '#f0f';
                    text.style.color = flash ? '#d0f' : '#f0f';
                    text.innerText = "ULTIMATE READY [PRESS SHIFT]";
                } else {
                    bar.style.backgroundColor = '#d0f'; 
                    bar.style.boxShadow = '0 0 10px #d0f';
                    text.style.color = '#d0f';
                    text.innerText = "ULTIMATE (SHIFT)";
                }
            }
        }

        function drawHpBar(ctx, hp, maxHp, yOffset, scale, angleFix = 0, cx = 0, cy = 0) {
            if (maxHp > 1 && hp < maxHp) {
                if(angleFix !== 0) ctx.rotate(angleFix);
                const w = 40 * scale;
                ctx.fillStyle = '#000'; ctx.fillRect(cx - w/2, cy - yOffset, w, 4);
                ctx.fillStyle = '#f00'; ctx.fillRect(cx - w/2, cy - yOffset, w * (hp/maxHp), 4);
                if(angleFix !== 0) ctx.rotate(-angleFix);
            }
        }

        function resetGame() {
            gameState.lives = 3;
            document.getElementById('lives-display').innerText = 'LIVES: ' + gameState.lives;
            player.hardReset(); 
            asteroids = []; bullets = []; particles = []; bonuses = [];
            ufos = []; worms = []; blackHoles = [];
            mines = []; aegises = []; hives = []; drones = []; lancers = []; tethers = [];
            tornados = []; reflectors = []; trailblazers = []; orbitals = []; prisms = []; repulsors = [];
            staticBeetles = []; phaseMantises = []; sniperMosquitos = []; clusterRoaches = []; roachMites = [];
            siphonFlies = []; webWeavers = []; webNodes = []; hawkShooters = [];
            nextWebGroupId = 1; nextWebNodeId = 1;
            mineShrapnels = [];
            bossWorms = [];
            bossLancers = [];
            bossOrbitals = []; // Reset new boss
            gameState.score = 0;
            // gameState.wave is already set by Start Game logic
            gameState.gameOver = false;
            gameState.autoFire = false;
            document.getElementById('game-over-screen').style.display = 'none';
            document.getElementById('score-display').innerText = 'SCORE: 0';
            updateHealthUI();
            updateUltUI();
            startWave();
        }

        function skipToLevel(lvl) {
            gameState.wave = lvl;
            asteroids = []; ufos = []; worms = []; blackHoles = [];
            mines = []; aegises = []; hives = []; drones = []; lancers = []; tethers = [];
            tornados = []; reflectors = []; trailblazers = []; orbitals = []; prisms = []; repulsors = [];
            staticBeetles = []; phaseMantises = []; sniperMosquitos = []; clusterRoaches = []; roachMites = [];
            siphonFlies = []; webWeavers = []; webNodes = []; hawkShooters = [];
            nextWebGroupId = 1; nextWebNodeId = 1;
            mineShrapnels = [];
            bossWorms = [];
            bossLancers = [];
            bossOrbitals = [];
            startWave();
        }

        function startWave() {
            document.getElementById('wave-display').innerText = 'WAVE: ' + gameState.wave;

            // Clear any leftover web hazards between waves so progression can't stall.
            // (Web nodes are obstacles, not enemies.)
            webNodes = [];
            nextWebGroupId = 1;
            nextWebNodeId = 1;
            
            // Cleanup Powerups at start of boss wave
            if (gameState.wave === 11 || gameState.wave === 22 || gameState.wave === 33) {
                 bonuses = []; 
                 if (player) {
                    player.shotLevel = 1; player.shotTimer = 0; player.rateLevel = 0; player.rateTimer = 0; player.reverseTimer = 0;
                    document.getElementById('powerup-status').innerText = "";
                 }
            }

            // BOSS WAVE 1 (Worms) - Wave 11
            if (gameState.wave === 11) {
                // Entering Boss Worm space: strip any existing armor buff
                if (player) {
                    player.armor = 0;
                    updateHealthUI();
                }
                bossWorms.push(new BossWorm(-100, canvas.height/2, 'fast'));
                bossWorms.push(new BossWorm(canvas.width + 100, canvas.height/2, 'dasher'));
                return;
            }

            // BOSS WAVE 2 (Lancers) - Wave 22
            if (gameState.wave === 22) {
                bossArmorTimer = 0;
                for(let i=0; i<5; i++) {
                    const bx = Math.random() * canvas.width; const by = -100 - Math.random() * 200; 
                    bossLancers.push(new BossLancer(bx, by));
                }
                return;
            }

            // BOSS WAVE 3 (Orbital) - Wave 33
            if (gameState.wave === 33) {
                bossOrbitals.push(new BossOrbital(canvas.width/2, -200));
                return;
            }

            let world = 1;
            let wWave = gameState.wave;

            if (gameState.wave > 11) { world = 2; wWave = gameState.wave - 11; }
            if (gameState.wave > 22) { world = 3; wWave = gameState.wave - 22; }
            if (gameState.wave > 33) { world = 4; wWave = gameState.wave - 33; }

            const baseSpawns = 4 + wWave * 2;
            const tier1Common = Math.floor(wWave * 0.8) + 1; 
            const tier1Uncommon = Math.floor(wWave * 0.5) + 1;
            
            let tier2Common = 0, tier2Uncommon = 0;
            if (wWave >= 4) { tier2Common = Math.floor((wWave - 3) * 0.8); tier2Uncommon = Math.floor((wWave - 3) * 0.6); }
            
            let tier3Common = 0, tier3Uncommon = 0;
            if (wWave >= 7) { tier3Common = Math.floor((wWave - 6) * 0.8); tier3Uncommon = Math.floor((wWave - 6) * 0.6); }

            let hazardTier1 = 0, hazardTier2 = 0, hazardTier3 = 0;
            if (wWave >= 3) hazardTier1 = 1 + Math.floor((wWave - 3)/2);
            if (wWave >= 6) hazardTier2 = 1 + Math.floor((wWave - 6)/2);
            if (wWave >= 9) hazardTier3 = 1 + Math.floor((wWave - 9)/2);

            let totalEnemies = tier1Common + tier1Uncommon + tier2Common + tier2Uncommon + tier3Common + tier3Uncommon + hazardTier1 + hazardTier2 + hazardTier3;

            // World-specific extra spawns
            let hawkCount = 0;
            let roachCount = 0;
            if (world === 3) totalEnemies += 1;
            if (world === 4) {
                hawkCount = 1 + Math.floor(wWave / 4);
                roachCount = wWave >= 2 ? (1 + Math.floor((wWave - 2) / 4)) : 0;
                totalEnemies += hawkCount + roachCount;
            }

            const fillerCount = Math.max(0, baseSpawns - totalEnemies);
            
            if (world === 1) {
                for (let i = 0; i < fillerCount; i++) spawnAsteroid(TIER_LARGE);
                for (let i = 0; i < tier1Common; i++) spawnUfo(TIER_SMALL);
                for (let i = 0; i < tier2Common; i++) spawnUfo(TIER_MED);
                for (let i = 0; i < tier3Common; i++) spawnUfo(TIER_LARGE);
                for (let i = 0; i < tier1Uncommon; i++) spawnWorm(TIER_SMALL);
                for (let i = 0; i < tier2Uncommon; i++) spawnWorm(TIER_MED);
                for (let i = 0; i < tier3Uncommon; i++) spawnWorm(TIER_LARGE);
                for (let i = 0; i < hazardTier1; i++) spawnBlackHole(TIER_SMALL);
                for (let i = 0; i < hazardTier2; i++) spawnBlackHole(TIER_MED);
                for (let i = 0; i < hazardTier3; i++) spawnBlackHole(TIER_LARGE);
            } else if (world === 2) {
                for (let i = 0; i < fillerCount; i++) spawnMine(TIER_LARGE);
                for (let i = 0; i < tier1Common; i++) spawnAegis(TIER_SMALL);
                for (let i = 0; i < tier2Common; i++) spawnAegis(TIER_MED);
                for (let i = 0; i < tier3Common; i++) spawnAegis(TIER_LARGE);
                for (let i = 0; i < tier1Uncommon; i++) spawnHive(TIER_SMALL);
                for (let i = 0; i < tier2Uncommon; i++) spawnHive(TIER_MED);
                for (let i = 0; i < tier3Uncommon; i++) spawnHive(TIER_LARGE);
                const h1 = hazardTier1; const h2 = hazardTier2; const h3 = hazardTier3;
                for(let i=0; i<h1; i++) i%2===0 ? spawnLancer(TIER_SMALL) : spawnTetherTwins(TIER_SMALL);
                for(let i=0; i<h2; i++) i%2===0 ? spawnLancer(TIER_MED) : spawnTetherTwins(TIER_MED);
                for(let i=0; i<h3; i++) i%2===0 ? spawnLancer(TIER_LARGE) : spawnTetherTwins(TIER_LARGE);
            } else if (world === 3) {
                spawnPrism(Math.min(TIER_LARGE, Math.ceil(wWave/3)));
                for (let i = 0; i < tier1Common; i++) spawnReflector(TIER_SMALL);
                for (let i = 0; i < tier2Common; i++) spawnReflector(TIER_MED);
                for (let i = 0; i < tier3Common; i++) spawnReflector(TIER_LARGE);
                if (wWave <= 5) {
                    for (let i = 0; i < tier1Uncommon; i++) spawnTornado(TIER_SMALL);
                    for (let i = 0; i < tier2Uncommon; i++) spawnTornado(TIER_MED);
                }
                if (wWave >= 4) {
                    const count = Math.floor((wWave-3)*0.7)+1;
                    for (let i = 0; i < count; i++) spawnTrailblazer(Math.min(TIER_LARGE, Math.floor(i/2)+1));
                }
                if (wWave >= 4) {
                    const count = Math.floor((wWave-3)*0.5)+1;
                    for (let i = 0; i < count; i++) spawnOrbital(Math.min(TIER_LARGE, Math.floor(i/2)+1));
                }
                if (wWave >= 3 && wWave <= 7) {
                    const count = 1 + Math.floor((wWave-3)/2);
                    for (let i = 0; i < count; i++) spawnRepulsor(Math.min(TIER_LARGE, i+1));
                }
            } else if (world === 4) {
                // World 4 (Waves 34-43): new enemies
                for (let i = 0; i < fillerCount; i++) spawnStaticBeetle(TIER_LARGE);

                for (let i = 0; i < tier1Common; i++) spawnStaticBeetle(TIER_SMALL);
                for (let i = 0; i < tier2Common; i++) spawnStaticBeetle(TIER_MED);
                for (let i = 0; i < tier3Common; i++) spawnStaticBeetle(TIER_LARGE);

                for (let i = 0; i < tier1Uncommon; i++) spawnSiphonFly(TIER_SMALL);
                for (let i = 0; i < tier2Uncommon; i++) spawnPhaseMantis(TIER_MED);
                for (let i = 0; i < tier3Uncommon; i++) spawnSniperMosquito(TIER_LARGE);

                for (let i = 0; i < hazardTier1; i++) spawnWebWeaver(TIER_SMALL);
                for (let i = 0; i < hazardTier2; i++) spawnWebWeaver(TIER_MED);
                for (let i = 0; i < hazardTier3; i++) spawnWebWeaver(TIER_LARGE);

                for (let i = 0; i < hawkCount; i++) spawnHawkShooter(Math.min(TIER_LARGE, 1 + Math.floor(wWave / 4)));
                for (let i = 0; i < roachCount; i++) spawnClusterRoach(Math.min(TIER_LARGE, 1 + Math.floor((wWave + 1) / 4)));
            }
        }

        function getSafeEdgePosition() {
            let x, y, d, attempts = 0;
            do {
                if (Math.random() < 0.5) {
                    x = Math.random() < 0.5 ? -20 : canvas.width + 20;
                    y = Math.random() * canvas.height;
                } else {
                    x = Math.random() * canvas.width;
                    y = Math.random() < 0.5 ? -20 : canvas.height + 20;
                }
                if (player) {
                    const dx = x - player.x; const dy = y - player.y; d = Math.sqrt(dx*dx + dy*dy);
                } else { d = 1000; }
                attempts++;
            } while (d < 210 && attempts < 15);
            return {x, y};
        }

        function spawnAsteroid(tier) { const pos = getSafeEdgePosition(); asteroids.push(new Asteroid(pos.x, pos.y, tier===TIER_LARGE?40:(tier===TIER_MED?25:15), tier)); }
        function spawnUfo(tier) { const pos = getSafeEdgePosition(); ufos.push(new Ufo(pos.x, pos.y, tier)); }
        function spawnWorm(tier) { const pos = getSafeEdgePosition(); worms.push(new SpaceWorm(pos.x, pos.y, tier)); }
        function spawnBlackHole(tier) {
            let x, y, dist, attempts = 0;
            do {
                x = Math.random() * (canvas.width - 100) + 50;
                y = Math.random() * (canvas.height - 100) + 50;
                if (player) { const dx = x - player.x; const dy = y - player.y; dist = Math.sqrt(dx*dx + dy*dy); } else { dist = 1000; }
                attempts++;
            } while (dist < 280 && attempts < 15); 
            blackHoles.push(new BlackHole(x, y, tier));
        }

        function spawnMine(tier) { const pos = getSafeEdgePosition(); mines.push(new Mine(pos.x, pos.y, tier===TIER_LARGE?40:(tier===TIER_MED?25:15), tier)); }
        function spawnAegis(tier) { const pos = getSafeEdgePosition(); aegises.push(new Aegis(pos.x, pos.y, tier)); }
        function spawnHive(tier) { const pos = getSafeEdgePosition(); hives.push(new Hive(pos.x, pos.y, tier)); }
        function spawnLancer(tier) { const pos = getSafeEdgePosition(); lancers.push(new Lancer(pos.x, pos.y, tier)); }
        let nextTetherGroupId = 1;
        function spawnTetherTwins(tier) {
            // Upgraded: spawn a 3-node equilateral "Teth Triangle".
            const pos = getSafeEdgePosition();
            const gid = nextTetherGroupId++;

            const scale = tier === TIER_LARGE ? 2 : (tier === TIER_MED ? 1.5 : 1);
            const side = 80 * scale;
            const r = side / Math.sqrt(3);
            const baseAng = Math.random() * Math.PI * 2;

            // Group velocity: constant slow random vector assigned to all members.
            const gAngle = Math.random() * Math.PI * 2;
            const gSpeed = 0.25 + Math.random() * 0.6; // slow base speed
            const gvx = Math.cos(gAngle) * gSpeed;
            const gvy = Math.sin(gAngle) * gSpeed;

            for (let k = 0; k < 3; k++) {
                const a = baseAng + (k / 3) * Math.PI * 2;
                const x = pos.x + Math.cos(a) * r;
                const y = pos.y + Math.sin(a) * r;
                const t = new TetherTwin(x, y, tier, gid);
                // initialize with the group velocity so they move together
                t.groupVx = gvx; t.groupVy = gvy;
                t.vx = gvx; t.vy = gvy;
                tethers.push(t);
            }
        }

        function spawnTornado(tier) { const pos = getSafeEdgePosition(); tornados.push(new Tornado(pos.x, pos.y, tier)); }
        function spawnReflector(tier) { const pos = getSafeEdgePosition(); reflectors.push(new Reflector(pos.x, pos.y, tier)); }
        function spawnTrailblazer(tier) { const pos = getSafeEdgePosition(); trailblazers.push(new Trailblazer(pos.x, pos.y, tier)); }
        function spawnOrbital(tier) { const pos = getSafeEdgePosition(); orbitals.push(new Orbital(pos.x, pos.y, tier)); }
        function spawnPrism(tier) {
            const x = Math.random() * (canvas.width - 100) + 50;
            const y = Math.random() * (canvas.height - 100) + 50;
            prisms.push(new Prism(x, y, tier));
        }
        function spawnRepulsor(tier) {
            let x, y, dist, attempts = 0;
            do {
                x = Math.random() * (canvas.width - 100) + 50;
                y = Math.random() * (canvas.height - 100) + 50;
                if (player) { const dx = x - player.x; const dy = y - player.y; dist = Math.sqrt(dx*dx + dy*dy); } else { dist = 1000; }
                attempts++;
            } while (dist < 280 && attempts < 15);
            repulsors.push(new Repulsor(x, y, tier));
        }

        // World 4 Spawns
        function spawnStaticBeetle(tier) { const pos = getSafeEdgePosition(); staticBeetles.push(new StaticBeetle(pos.x, pos.y, tier)); }
        function spawnPhaseMantis(tier) { const pos = getSafeEdgePosition(); phaseMantises.push(new PhaseMantis(pos.x, pos.y, tier)); }
        function spawnSniperMosquito(tier) {
            const margin = 40;
            const x = Math.random() < 0.5 ? margin : canvas.width - margin;
            const y = Math.random() * (canvas.height - margin * 2) + margin;
            sniperMosquitos.push(new SniperMosquito(x, y, tier));
        }
        function spawnClusterRoach(tier) { const pos = getSafeEdgePosition(); clusterRoaches.push(new ClusterRoach(pos.x, pos.y, tier)); }
        function spawnSiphonFly(tier) { const pos = getSafeEdgePosition(); siphonFlies.push(new SiphonFly(pos.x, pos.y, tier)); }
        function spawnWebWeaver(tier) { const pos = getSafeEdgePosition(); webWeavers.push(new WebWeaver(pos.x, pos.y, tier)); }
        function spawnHawkShooter(tier) { const pos = getSafeEdgePosition(); hawkShooters.push(new HawkShooter(pos.x, pos.y, tier)); }

        function spawnBonus(x, y, multiplier = 1) {
            if (Math.random() < 0.30 * multiplier) {
                let types = [0, 1, 3, 4];
                if (player.armor < 100) types.push(2); 
                if (player.reverseTimer <= 0) types.push(5);
                const typeIndex = types[Math.floor(Math.random() * types.length)];
                bonuses.push(new Bonus(x, y, typeIndex));
            }
        }

        function collectBonus(b) {
            if (b.type === 0) { 
                player.shotLevel = Math.min(player.shotLevel + 1, 5); player.shotTimer = 1200;
                createFloatingText('MULTI-SHOT X' + player.shotLevel, player.x, player.y);
            } else if (b.type === 1) { 
                player.rateLevel = Math.min(player.rateLevel + 1, 4); player.rateTimer = 1200;
                createFloatingText('RAPID FIRE X' + player.rateLevel, player.x, player.y);
            } else if (b.type === 2) { 
                player.armor = Math.min(player.armor + 50, 100); createFloatingText('SHIELD UP', player.x, player.y);
            } else if (b.type === 3) { 
                player.health = Math.min(player.health + 33, 100); createFloatingText('REPAIR', player.x, player.y);
            } else if (b.type === 4) { 
                explodeArea(player.x, player.y, 375); createFloatingText('SHOCKWAVE', player.x, player.y);
            } else if (b.type === 5) { 
                player.reverseTimer = 1200; createFloatingText('REVERSE FIRE', player.x, player.y);
            }
            updateHealthUI(); playSound('powerup');
        }

        function explodeArea(x, y, radius) {
            for(let i=0; i<30; i++) particles.push(new Particle(x, y, '#f50', 8, 4, 30));
            const numBullets = 16;
            for (let i = 0; i < numBullets; i++) {
                const angle = (i / numBullets) * Math.PI * 2;
                bullets.push(new Bullet(x, y, angle));
            }
            shakeAmount = 20; playSound('explosion');

            const checkExplode = (arr, destroyFn) => {
                for (let j = arr.length - 1; j >= 0; j--) {
                    let e = arr[j];
                    if (!e) continue;
                    let pos = (e.head && {x: e.head.x, y: e.head.y}) || (e.x !== undefined ? {x: e.x, y: e.y} : null);
                    if (!pos) continue;
                    if (dist({x,y}, pos) < radius) {
                        if (e.takeDamage) { if(e.takeDamage(5)) destroyFn(j); }
                        else destroyFn(j);
                    }
                }
            };
            checkExplode(asteroids, destroyAsteroid); checkExplode(ufos, destroyUfo); checkExplode(worms, destroyWorm);
            checkExplode(blackHoles, destroyBlackHole); checkExplode(mines, destroyMine); checkExplode(aegises, destroyAegis);
            checkExplode(hives, destroyHive); checkExplode(drones, destroyDrone); checkExplode(lancers, destroyLancer);
            checkExplode(tethers, destroyTether); checkExplode(tornados, destroyTornado); checkExplode(reflectors, destroyReflector);
            checkExplode(trailblazers, destroyTrailblazer); checkExplode(orbitals, destroyOrbital); checkExplode(prisms, destroyPrism);
            checkExplode(repulsors, destroyRepulsor); checkExplode(bossWorms, destroyBossWorm); checkExplode(bossLancers, destroyBossLancer);
            checkExplode(bossOrbitals, destroyBossOrbital);
        }

        function createFloatingText(text, x, y) {
            const el = document.createElement('div');
            el.className = 'floating-text';
            el.style.left = x + 'px'; el.style.top = y + 'px';
            el.style.color = '#ff0';
            el.innerText = text;
            document.getElementById('floating-text-layer').appendChild(el);
            setTimeout(() => { if(el.parentNode) el.parentNode.removeChild(el); }, 1000);
        }
        
        function destroyBossOrbital(i) { genericDestroy(bossOrbitals, i, '#f00', 8000); }
        function destroyBossLancer(i) { genericDestroy(bossLancers, i, '#f08', 6000); }
        function destroyBossWorm(i) { genericDestroy(bossWorms, i, '#f00', 5000); }

        function genericDestroy(arr, index, color, scoreBase) {
             let e = arr[index]; arr.splice(index, 1);
             let ex = e.x || (e.head ? e.head.x : 0); let ey = e.y || (e.head ? e.head.y : 0);
             spawnParticles(ex, ey, color);
             let mult = e.scale ? e.scale * 1.5 : 1; spawnBonus(ex, ey, mult);
             let pts = (scoreBase || 100); if (e.tier) pts *= e.tier;
             gameState.score += pts; finishKill();
        }
        
        function destroyAsteroid(i) { genericDestroy(asteroids, i, COLOR_ASTEROID, 100); }
        function destroyUfo(i) { genericDestroy(ufos, i, COLOR_UFO, 500); }
        function destroyWorm(i) { genericDestroy(worms, i, COLOR_WORM, 600); }
        function destroyBlackHole(i) { genericDestroy(blackHoles, i, COLOR_BLACKHOLE, 800); }
        function destroyMine(i) { 
            let m = mines[i]; if (!m) return;
            if (player) { for(let k=0; k<4; k++) mineShrapnels.push(new MineShrapnel(m.x, m.y, player, k)); }
            genericDestroy(mines, i, COLOR_MINE, 200); 
        }
        function destroyAegis(i) { genericDestroy(aegises, i, COLOR_AEGIS, 600); }
        function destroyHive(i) { genericDestroy(hives, i, COLOR_HIVE, 1000); }
        function destroyDrone(i) { 
            let d = drones[i]; drones.splice(i, 1); spawnParticles(d.x, d.y, COLOR_HIVE); 
            gameState.score += 50; finishKill(); 
        }
        function destroyLancer(i) { genericDestroy(lancers, i, COLOR_LANCER, 700); }
        function destroyTether(i, _fromCollapse = false) {
            const t = tethers[i];
            if (!t) return;
            const gid = t.groupId;
            genericDestroy(tethers, i, COLOR_TETHER, 800);

            // If two of the triangle nodes die, collapse the group by killing the last one.
            if (_fromCollapse) return;
            const remaining = [];
            for (let k = 0; k < tethers.length; k++) {
                const e = tethers[k];
                if (e && !e.dead && e.groupId === gid) remaining.push(k);
            }
            if (remaining.length <= 1) {
                for (let k = remaining.length - 1; k >= 0; k--) destroyTether(remaining[k], true);
            }
        }
        function destroyTornado(i) { genericDestroy(tornados, i, COLOR_TORNADO, 600); }
        function destroyReflector(i) { genericDestroy(reflectors, i, COLOR_REFLECTOR, 700); }
        function destroyTrailblazer(i) { genericDestroy(trailblazers, i, COLOR_TRAIL, 700); }
        function destroyOrbital(i) { genericDestroy(orbitals, i, COLOR_ORBITAL_CORE, 900); }
        function destroyPrism(i) { genericDestroy(prisms, i, COLOR_PRISM, 2000); }
        function destroyRepulsor(i) { genericDestroy(repulsors, i, COLOR_REPULSOR, 800); }

        // World 4
        function destroyStaticBeetle(i) { genericDestroy(staticBeetles, i, '#ff0', 900); }
        function destroyPhaseMantis(i) { genericDestroy(phaseMantises, i, '#fff', 1200); }
        function destroySniperMosquito(i) { genericDestroy(sniperMosquitos, i, '#f00', 1500); }
        function destroySiphonFly(i) { genericDestroy(siphonFlies, i, '#d0f', 800); }
        function destroyWebWeaver(i) {
            const w = webWeavers[i]; if (!w) return;
            const gid = w.webGroupId;
            // Remove associated web nodes (no extra score) and spawn small particles for feedback
            for (let j = webNodes.length - 1; j >= 0; j--) {
                if (webNodes[j].groupId === gid) {
                    const n = webNodes.splice(j, 1)[0];
                    spawnParticles(n.x, n.y, '#0ff');
                }
            }
            // Now destroy the weaver itself (awards score / particles)
            genericDestroy(webWeavers, i, '#0ff', 1500);
        }
        function destroyHawkShooter(i) { genericDestroy(hawkShooters, i, '#fa0', 1400); }

        function destroyWebNode(i) {
            const n = webNodes[i]; if (!n) return;
            webNodes.splice(i, 1);
            spawnParticles(n.x, n.y, '#0ff');
            gameState.score += 25;
            document.getElementById('score-display').innerText = 'SCORE: ' + gameState.score;
            playSound('shoot');
            checkWaveEnd();
        }

        function destroyRoachMite(i) {
            const m = roachMites[i]; if (!m) return;
            roachMites.splice(i, 1);
            spawnParticles(m.x, m.y, '#0f0');
            gameState.score += 150;
            finishKill();
        }

        function destroyClusterRoach(i) {
            const r = clusterRoaches[i]; if (!r) return;
            clusterRoaches.splice(i, 1);
            spawnParticles(r.x, r.y, '#0f0');
            for (let k = 0; k < 3; k++) roachMites.push(new RoachMite(r.x, r.y, Math.min(TIER_LARGE, r.tier)));
            gameState.score += 1200;
            finishKill();
        }

        function finishKill() {
            document.getElementById('score-display').innerText = 'SCORE: ' + gameState.score;
            playSound('explosion'); shakeAmount = 10; checkWaveEnd();
        }

        function checkWaveEnd() {
            if (asteroids.length === 0 && ufos.length === 0 && worms.length === 0 && blackHoles.length === 0 &&
                mines.length === 0 && aegises.length === 0 && hives.length === 0 && lancers.length === 0 && tethers.length === 0 &&
                drones.length === 0 &&
                tornados.length === 0 && reflectors.length === 0 && trailblazers.length === 0 && orbitals.length === 0 && prisms.length === 0 && repulsors.length === 0 &&
                staticBeetles.length === 0 && phaseMantises.length === 0 && sniperMosquitos.length === 0 && clusterRoaches.length === 0 && roachMites.length === 0 &&
                siphonFlies.length === 0 && webWeavers.length === 0 && hawkShooters.length === 0 &&
                bossWorms.length === 0 && bossLancers.length === 0 && bossOrbitals.length === 0) {
                
                gameState.wave++;
                checkUnlocks();
                setTimeout(startWave, 1000);
            }
        }

        function spawnParticles(x, y, color) {
            for (let i=0; i<10; i++) particles.push(new Particle(x, y, color, 3, 2, 40));
        }

        function takeDamage(amount, breakArmor = false) {
            let died = false;
            if (breakArmor) player.armor = 0;
            if (player.armor > 0) {
                player.armor -= amount;
                if (player.armor < 0) { player.health += player.armor; player.armor = 0; }
            } else player.health -= amount;

            player.invulnerable = 60; shakeAmount = 20; updateHealthUI();
            spawnParticles(player.x, player.y, COLOR_PLAYER);
            
            if (player.health <= 0) { handleDeath(); died = true; }
            return died;
        }
        
        function handleDeath() {
            gameState.lives--;
            document.getElementById('lives-display').innerText = 'LIVES: ' + gameState.lives;
            
            if (gameState.lives > 0) {
                player.respawn(); 
                const safetyRadius = 300;
                const filterArr = (arr) => arr.filter(e => dist(player, e.head || e) > safetyRadius);
                asteroids = filterArr(asteroids); ufos = filterArr(ufos); worms = filterArr(worms); blackHoles = filterArr(blackHoles);
                mines = filterArr(mines); aegises = filterArr(aegises); hives = filterArr(hives); drones = filterArr(drones);
                lancers = filterArr(lancers); tethers = filterArr(tethers); tornados = filterArr(tornados); reflectors = filterArr(reflectors);
                trailblazers = filterArr(trailblazers); orbitals = filterArr(orbitals); prisms = filterArr(prisms); repulsors = filterArr(repulsors);
                mineShrapnels = filterArr(mineShrapnels);
                staticBeetles = filterArr(staticBeetles); phaseMantises = filterArr(phaseMantises); sniperMosquitos = filterArr(sniperMosquitos);
                clusterRoaches = filterArr(clusterRoaches); roachMites = filterArr(roachMites); siphonFlies = filterArr(siphonFlies);
                webWeavers = filterArr(webWeavers);
                // If a WebWeaver gets removed by the safety filter, also remove its entire web.
                const aliveWebGroups = new Set(webWeavers.map(w => w.webGroupId));
                webNodes = webNodes.filter(n => aliveWebGroups.has(n.groupId));
                hawkShooters = filterArr(hawkShooters);
                checkWaveEnd();
            } else {
                gameOver();
            }
        }

        function gameOver() {
            gameState.gameOver = true;
            document.getElementById('final-score').innerText = 'FINAL SCORE: ' + gameState.score;
            document.getElementById('game-over-screen').style.display = 'block';
        }

        function checkCollisions() {
            // 1. Ultimate Laser
            if (player.ultActive) {
                const lx = player.x; const ly = player.y; const angle = player.angle;
                const checkLaserHit = (obj, radius) => {
                    const dx = obj.x - lx; const dy = obj.y - ly;
                    const rx = dx * Math.cos(-angle) - dy * Math.sin(-angle);
                    const ry = dx * Math.sin(-angle) + dy * Math.cos(-angle);
                    return (rx > 0 && rx < LASER_LENGTH && Math.abs(ry) < (LASER_WIDTH/2 + radius));
                };

                asteroids.forEach((a, i) => { if (checkLaserHit(a, a.size)) destroyAsteroid(i); });
                ufos.forEach((u, i) => { if (checkLaserHit(u, u.size) && u.takeDamage(0.5)) destroyUfo(i); });
                worms.forEach((w, i) => { if (checkLaserHit(w.head, w.radius) && w.takeDamage(0.5)) destroyWorm(i); });
                blackHoles.forEach((b, i) => { if (checkLaserHit(b, b.size) && b.takeDamage(0.5)) destroyBlackHole(i); });
                mines.forEach((m, i) => { if (checkLaserHit(m, m.size)) destroyMine(i); });
                aegises.forEach((a, i) => { if (checkLaserHit(a, a.size) && a.takeDamage(0.5)) destroyAegis(i); });
                hives.forEach((h, i) => { if (checkLaserHit(h, h.size) && h.takeDamage(0.5)) destroyHive(i); });
                drones.forEach((d, i) => { if (checkLaserHit(d, d.size)) destroyDrone(i); });
                lancers.forEach((l, i) => { if (checkLaserHit(l, l.size) && l.takeDamage(0.5)) destroyLancer(i); });
                tethers.forEach((t, i) => { if (checkLaserHit(t, t.size) && t.takeDamage(0.5)) destroyTether(i); });
                
                tornados.forEach((e, i) => { if (checkLaserHit(e, e.size) && e.takeDamage(0.5)) destroyTornado(i); });
                reflectors.forEach((e, i) => { if (checkLaserHit(e, e.size) && e.takeDamage(0.5)) destroyReflector(i); });
                trailblazers.forEach((e, i) => { if (checkLaserHit(e, e.size) && e.takeDamage(0.5)) destroyTrailblazer(i); });
                orbitals.forEach((e, i) => { if (checkLaserHit(e, e.size) && e.takeDamage(0.5)) destroyOrbital(i); });
                prisms.forEach((e, i) => { if (checkLaserHit(e, e.size) && e.takeDamage(0.5)) destroyPrism(i); });
                repulsors.forEach((e, i) => { if (checkLaserHit(e, e.size) && e.takeDamage(0.5)) destroyRepulsor(i); });

                // World 4
                staticBeetles.forEach((e, i) => { if (checkLaserHit(e, e.size) && e.takeDamage(0.5)) destroyStaticBeetle(i); });
                phaseMantises.forEach((e, i) => { if (e.visible && checkLaserHit(e, e.size) && e.takeDamage(0.5)) destroyPhaseMantis(i); });
                sniperMosquitos.forEach((e, i) => { if (checkLaserHit(e, e.size) && e.takeDamage(0.5)) destroySniperMosquito(i); });
                clusterRoaches.forEach((e, i) => { if (checkLaserHit(e, e.size) && e.takeDamage(0.5)) destroyClusterRoach(i); });
                roachMites.forEach((e, i) => { if (checkLaserHit(e, e.size) && e.takeDamage(0.5)) destroyRoachMite(i); });
                siphonFlies.forEach((e, i) => { if (checkLaserHit(e, e.size) && e.takeDamage(0.5)) destroySiphonFly(i); });
                webWeavers.forEach((e, i) => { if (checkLaserHit(e, e.size) && e.takeDamage(0.5)) destroyWebWeaver(i); });
                webNodes.forEach((e, i) => { if (checkLaserHit(e, e.size) && e.takeDamage(0.5)) destroyWebNode(i); });
                hawkShooters.forEach((e, i) => { if (checkLaserHit(e, e.size) && e.takeDamage(0.5)) destroyHawkShooter(i); });

                mineShrapnels.forEach((s, i) => { if (checkLaserHit(s, s.size)) { mineShrapnels.splice(i, 1); spawnParticles(s.x, s.y, COLOR_MINE); } });
                
                // Bosses are immune to the ultimate laser — no damage applied here.
            }

            // 2. Bullets
            for (let i = bullets.length - 1; i >= 0; i--) {
                let b = bullets[i];
                let hit = false;
                
                // Helper for simple circle hit
                const checkOneHit = (arr, destroyFn) => {
                    for (let j = arr.length - 1; j >= 0; j--) {
                        if (dist(b, arr[j]) < arr[j].size) {
                            if (b.owner === 'player') destroyFn(j);
                            hit = true; return true;
                        }
                    }
                    return false;
                };

                if (!hit) checkOneHit(asteroids, destroyAsteroid);
                if (!hit) checkOneHit(mines, destroyMine);
                if (!hit) {
                    for (let j = mineShrapnels.length - 1; j >= 0; j--) {
                        if (dist(b, mineShrapnels[j]) < mineShrapnels[j].size) {
                            if (b.owner === 'player') { mineShrapnels.splice(j, 1); spawnParticles(b.x, b.y, COLOR_MINE); }
                            hit = true; break;
                        }
                    }
                }

                if (!hit && b.owner === 'player') {
                    // Aegis Shield Logic
                    for (let j = aegises.length - 1; j >= 0; j--) {
                        let a = aegises[j];
                        if (dist(b, a) < a.size + 5) {
                            const angleToBullet = Math.atan2(b.y - a.y, b.x - a.x);
                            let angleDiff = Math.abs(angleToBullet - a.angle);
                            while(angleDiff > Math.PI) angleDiff -= Math.PI*2;
                            angleDiff = Math.abs(angleDiff);
                            if (angleDiff < Math.PI/3) playSound('shoot'); // Shield Hit
                            else if (a.takeDamage(1)) destroyAegis(j);
                            hit = true; break;
                        }
                    }
                    
                    // Orbital Shield Logic
                    if(!hit) {
                        for (let j = orbitals.length - 1; j >= 0; j--) {
                            let e = orbitals[j]; let shieldHit = false;
                            for(let k=0; k<3; k++) {
                                const a = e.orbAngle + (k/3)*Math.PI*2;
                                const ox = e.x + Math.cos(a)*e.orbDist; const oy = e.y + Math.sin(a)*e.orbDist;
                                if (Math.sqrt((b.x-ox)**2 + (b.y-oy)**2) < e.orbSize+5) { shieldHit = true; break; }
                            }
                            if (shieldHit) { playSound('shoot'); hit = true; break; }
                            if (dist(b, e) < e.size + 5) { if (e.takeDamage(1)) destroyOrbital(j); hit = true; break; }
                        }
                    }
                    
                    // Boss Orbital Logic
                    if(!hit) {
                        for (let j = bossOrbitals.length - 1; j >= 0; j--) {
                            let e = bossOrbitals[j]; let shieldHit = false;
                            // Inner orbs
                            for(let k=0; k<3; k++) {
                                const a = e.orbAngle + (k/3)*Math.PI*2;
                                const ox = e.x + Math.cos(a)*40; const oy = e.y + Math.sin(a)*40;
                                if (Math.sqrt((b.x-ox)**2 + (b.y-oy)**2) < 8+5) { shieldHit = true; break; }
                            }
                            if (shieldHit) { playSound('shoot'); hit = true; break; }
                            if (dist(b, e) < e.size + 5) { if (e.takeDamage(1)) destroyBossOrbital(j); hit = true; break; }
                        }
                    }

                    // Standard HP Enemies
                    if (!hit) {
                        const checkHpEnemy = (arr, destroyFn, sizeProp = 'size', isWorm = false) => {
                            for (let j = arr.length - 1; j >= 0; j--) {
                                let e = arr[j]; let pos = isWorm ? e.head : e; let sz = isWorm ? e.radius : e[sizeProp];
                                if (dist(b, pos) < sz + 5) { if (e.takeDamage(1)) destroyFn(j); hit = true; return true; }
                            }
                            return false;
                        };
                        if (!hit) checkHpEnemy(ufos, destroyUfo); if (!hit) checkHpEnemy(worms, destroyWorm, 'radius', true);
                        if (!hit) checkHpEnemy(blackHoles, destroyBlackHole); if (!hit) checkHpEnemy(hives, destroyHive);
                        if (!hit) checkHpEnemy(lancers, destroyLancer); if (!hit) checkHpEnemy(tethers, destroyTether);
                        if (!hit) checkHpEnemy(tornados, destroyTornado); if (!hit) checkHpEnemy(reflectors, destroyReflector);
                        if (!hit) checkHpEnemy(trailblazers, destroyTrailblazer); if (!hit) checkHpEnemy(prisms, destroyPrism);
                        if (!hit) checkHpEnemy(repulsors, destroyRepulsor);

                        // World 4
                        if (!hit) checkHpEnemy(staticBeetles, destroyStaticBeetle);
                        if (!hit) checkHpEnemy(phaseMantises, destroyPhaseMantis);
                        if (!hit) checkHpEnemy(sniperMosquitos, destroySniperMosquito);
                        if (!hit) checkHpEnemy(clusterRoaches, destroyClusterRoach);
                        if (!hit) checkHpEnemy(roachMites, destroyRoachMite);
                        if (!hit) checkHpEnemy(siphonFlies, destroySiphonFly);
                        if (!hit) checkHpEnemy(webWeavers, destroyWebWeaver);
                        if (!hit) checkHpEnemy(webNodes, destroyWebNode);
                        if (!hit) checkHpEnemy(hawkShooters, destroyHawkShooter);
                        
                        // Bosses
                        if (!hit) {
                            for (let j = bossWorms.length - 1; j >= 0; j--) {
                                let bWorm = bossWorms[j];
                                if (dist(b, bWorm.head) < bWorm.radius + 5) { if (bWorm.takeDamage(1)) destroyBossWorm(j); hit = true; break; }
                            }
                        }
                        if (!hit) {
                            for(let j=bossLancers.length-1; j>=0; j--) {
                                let bl = bossLancers[j];
                                if (dist(b, bl) < bl.size + 5) { if (bl.takeDamage(1)) destroyBossLancer(j); hit = true; break; }
                            }
                        }
                        if (!hit) {
                            for(let j=drones.length-1; j>=0; j--) { if (dist(b, drones[j]) < drones[j].size) { destroyDrone(j); hit = true; break; } }
                        }
                    }
                }

                if (!hit && b.owner === 'enemy' && player.invulnerable <= 0) {
                     if (dist(b, player) < PLAYER_SIZE) { if (takeDamage(15)) return; hit = true; }
                }
                if (hit) bullets.splice(i, 1);
            }

            // 3. Player Crash
            if (player.invulnerable <= 0) {
                const checkCrash = (arr, destroyFn, dmg, sizeProp='size', isWorm=false) => {
                    for (let j = arr.length - 1; j >= 0; j--) {
                        let e = arr[j]; let pos = isWorm ? e.head : e; let sz = isWorm ? e.radius : e[sizeProp];
                        if (dist(player, pos) < sz + PLAYER_SIZE) {
                            if (takeDamage(dmg)) return true;
                            if (destroyFn) { if(e.takeDamage && e.takeDamage(10)) destroyFn(j); else if (!e.takeDamage) destroyFn(j); }
                            return false; 
                        }
                    }
                    return false;
                };

                if (checkCrash(asteroids, destroyAsteroid, 20)) return; if (checkCrash(mines, destroyMine, 30)) return;
                if (checkCrash(ufos, destroyUfo, 20)) return; if (checkCrash(worms, destroyWorm, 40, 'radius', true)) return;
                if (checkCrash(blackHoles, destroyBlackHole, 20)) return; if (checkCrash(aegises, destroyAegis, 20)) return;
                if (checkCrash(hives, destroyHive, 20)) return; if (checkCrash(drones, destroyDrone, 10)) return;
                if (checkCrash(lancers, destroyLancer, 25)) return; if (checkCrash(tethers, destroyTether, 20)) return;
                if (checkCrash(tornados, destroyTornado, 33)) return; if (checkCrash(reflectors, destroyReflector, 20)) return;
                if (checkCrash(trailblazers, destroyTrailblazer, 20)) return; if (checkCrash(orbitals, destroyOrbital, 20)) return;
                if (checkCrash(prisms, destroyPrism, 30)) return; if (checkCrash(repulsors, destroyRepulsor, 20)) return;

                // World 4 crash
                if (checkCrash(staticBeetles, destroyStaticBeetle, 25)) return;
                if (checkCrash(phaseMantises, destroyPhaseMantis, 20)) return;
                if (checkCrash(sniperMosquitos, destroySniperMosquito, 20)) return;
                if (checkCrash(clusterRoaches, destroyClusterRoach, 35)) return;
                if (checkCrash(roachMites, destroyRoachMite, 10)) return;
                if (checkCrash(siphonFlies, destroySiphonFly, 10)) return;
                if (checkCrash(webWeavers, destroyWebWeaver, 20)) return;
                if (checkCrash(hawkShooters, destroyHawkShooter, 20)) return;

                // Static Beetle arc: dampen move + rotation for 2s
                for (let j = staticBeetles.length - 1; j >= 0; j--) {
                    const sb = staticBeetles[j];
                    const tips = sb.getArcTips();
                    const d = pointToSegmentDistance(player.x, player.y, tips.ax, tips.ay, tips.bx, tips.by);
                    if (d < PLAYER_SIZE + 6) player.dampenTimer = Math.max(player.dampenTimer, 120);
                }

                // Siphon Fly: drain 15% ult on contact (cooldown per fly)
                for (let j = siphonFlies.length - 1; j >= 0; j--) {
                    const sf = siphonFlies[j];
                    if (sf.drainCooldown > 0) continue;
                    if (dist(player, sf) < sf.size + PLAYER_SIZE + 6) {
                        sf.drainCooldown = 30;
                        player.ultCharge = Math.max(0, player.ultCharge - 15);
                        updateUltUI();
                        playSound('shoot');
                    }
                }

                // Web Nodes / Lines: grid-lock for 0.5s
                if (webNodes.length > 0) {
                    const byId = new Map();
                    for (let i = 0; i < webNodes.length; i++) byId.set(webNodes[i].id, webNodes[i]);
                    for (let i = 0; i < webNodes.length; i++) {
                        const n = webNodes[i];
                        if (dist(player, n) < PLAYER_SIZE + n.size * 0.6) player.gridLockTimer = Math.max(player.gridLockTimer, 30);
                        if (n.prevId != null) {
                            const p = byId.get(n.prevId);
                            if (p) {
                                const d = pointToSegmentDistance(player.x, player.y, n.x, n.y, p.x, p.y);
                                if (d < PLAYER_SIZE + 5) player.gridLockTimer = Math.max(player.gridLockTimer, 30);
                            }
                        }
                    }
                }
                
                // Boss Collision
                for (let j = bossWorms.length - 1; j >= 0; j--) {
                    let bWorm = bossWorms[j];
                    if (dist(player, bWorm.head) < bWorm.radius + PLAYER_SIZE) { if(takeDamage(40)) return; }
                    // Antennae line collision
                    // Use wrap-aware points near the head to avoid phantom long lines.
                    const W = canvas.width; const H = canvas.height;
                    const wrapPointNear = (ax, ay, bx, by) => {
                        let x = bx; let y = by;
                        let dx = x - ax; let dy = y - ay;
                        if (Math.abs(dx) > W / 2) x -= Math.sign(dx) * W;
                        if (Math.abs(dy) > H / 2) y -= Math.sign(dy) * H;
                        return { x, y };
                    };
                    const A = wrapPointNear(bWorm.head.x, bWorm.head.y, bWorm.ant1.x, bWorm.ant1.y);
                    const B = wrapPointNear(bWorm.head.x, bWorm.head.y, bWorm.ant2.x, bWorm.ant2.y);
                    const l2 = dist(A, B)**2;
                    if (l2 > 0) {
                        let t = ((player.x - A.x) * (B.x - A.x) + (player.y - A.y) * (B.y - A.y)) / l2; t = Math.max(0, Math.min(1, t));
                        const projX = A.x + t * (B.x - A.x); const projY = A.y + t * (B.y - A.y);
                        if (Math.sqrt((player.x - projX)**2 + (player.y - projY)**2) < PLAYER_SIZE + 4) { if(takeDamage(0.2 * 10)) return; }
                    }
                }

                for (let j = bossLancers.length - 1; j >= 0; j--) {
                    let bl = bossLancers[j];
                    if (dist(player, bl) < bl.size + PLAYER_SIZE) { if(takeDamage(40)) return; }
                    if (bl.laserActive) {
                        const angle = bl.laserAngle; const x2 = bl.x + Math.cos(angle) * 300; const y2 = bl.y + Math.sin(angle) * 300;
                        const l2 = dist({x:bl.x, y:bl.y}, {x:x2, y:y2})**2;
                        if (l2 == 0) continue;
                        let t = ((player.x - bl.x) * (x2 - bl.x) + (player.y - bl.y) * (y2 - bl.y)) / l2; t = Math.max(0, Math.min(1, t));
                        const px = bl.x + t * (x2 - bl.x); const py = bl.y + t * (y2 - bl.y);
                        if (Math.sqrt((player.x - px)**2 + (player.y - py)**2) < PLAYER_SIZE + 5) { if(takeDamage(2)) return; }
                    }
                }
                
                for(let j=bossOrbitals.length-1; j>=0; j--) {
                    let bo = bossOrbitals[j];
                    // Core Body Collision
                    if (dist(player, bo) < bo.size + PLAYER_SIZE) { if(takeDamage(40)) return; }

                    // Inner Shield Orbs (Damage)
                    for(let k=0; k<3; k++) {
                        const a = bo.orbAngle + (k/3)*Math.PI*2;
                        const ox = bo.x + Math.cos(a) * bo.orbDist;
                        const oy = bo.y + Math.sin(a) * bo.orbDist;
                        if (dist(player, {x:ox, y:oy}) < bo.orbSize + PLAYER_SIZE) {
                             if(takeDamage(20)) return;
                        }
                    }

                    // Outer Gravity Orbs (Semi-Paralyze / Slow)
                    if (bo.outerActive) {
                         const outerDist = bo.orbDist * 2.5; 
                         const orbCount = 12;
                         for(let k=0; k<orbCount; k++) {
                             const a = -bo.orbAngle + (k/orbCount)*Math.PI*2;
                             const ox = bo.x + Math.cos(a) * outerDist; 
                             const oy = bo.y + Math.sin(a) * outerDist;
                             if (dist(player, {x:ox, y:oy}) < 25 + PLAYER_SIZE) { 
                                // Hit by an outer orb: apply a 3s heavy slow (75% speed reduction)
                                player.slowTimer = 180;
                             }
                         }
                    }
                }

                for (let j = mineShrapnels.length - 1; j >= 0; j--) {
                    let s = mineShrapnels[j];
                    if (dist(player, s) < s.size + PLAYER_SIZE) { if (takeDamage(10)) return; mineShrapnels.splice(j, 1); }
                }
                
                // Tether Logic (Triangle groups): player takes damage if crossing any live beam edge.
                let beamHit = false;
                const aliveTethers = tethers.filter(t => t && !t.dead);
                const groups = new Map();
                for (const t of aliveTethers) {
                    const arr = groups.get(t.groupId) || [];
                    arr.push(t);
                    groups.set(t.groupId, arr);
                }

                for (const arr of groups.values()) {
                    if (arr.length < 2) continue;
                    for (let i = 0; i < arr.length; i++) {
                        for (let j = i + 1; j < arr.length; j++) {
                            if (beamHit) break;
                            const A = arr[i];
                            const B = arr[j];
                            const P = player;
                            const l2 = dist(A, B) ** 2;
                            if (l2 === 0) continue;
                            let tVal = ((P.x - A.x) * (B.x - A.x) + (P.y - A.y) * (B.y - A.y)) / l2;
                            tVal = Math.max(0, Math.min(1, tVal));
                            const projX = A.x + tVal * (B.x - A.x);
                            const projY = A.y + tVal * (B.y - A.y);
                            if (Math.sqrt((P.x - projX) ** 2 + (P.y - projY) ** 2) < PLAYER_SIZE + 4) {
                                // apply damage and a 75% slow for 3s (180 frames)
                                player.slowTimer = Math.max(player.slowTimer || 0, 180);
                                if (takeDamage(1, true)) beamHit = true;
                            }
                        }
                        if (beamHit) break;
                    }
                    if (beamHit) break;
                }
                if (beamHit) return;

                // Prism Logic
                let prismHit = false;
                prisms.forEach(p => {
                    if(!prismHit) {
                        const dx = player.x - p.x; const dy = player.y - p.y;
                        const rx = dx * Math.cos(-p.angle) - dy * Math.sin(-p.angle); const ry = dx * Math.sin(-p.angle) + dy * Math.cos(-p.angle);
                        if (ry < 0 && Math.abs(rx) < PLAYER_SIZE + 2) { if(takeDamage(1, true)) prismHit = true; }
                    }
                });
                if (prismHit) return;

                // Trailblazer Logic
                let trailHit = false;
                trailblazers.forEach(tb => {
                    if(!trailHit) {
                        for(let i=0; i<tb.trail.length-1; i++) {
                            const p1 = tb.trail[i]; const p2 = tb.trail[i+1];
                            const A = p1; const B = p2; const P = player; const l2 = dist(A, B)**2;
                            if (l2 == 0) continue;
                            let t = ((P.x - A.x) * (B.x - A.x) + (P.y - A.y) * (B.y - A.y)) / l2; t = Math.max(0, Math.min(1, t));
                            const projX = A.x + t * (B.x - A.x); const projY = A.y + t * (B.y - A.y);
                            if (Math.sqrt((P.x - projX)**2 + (P.y - projY)**2) < PLAYER_SIZE + 4) { if(takeDamage(1)) { trailHit = true; break; } }
                        }
                    }
                });
                if(trailHit) return;
            }

            // 4. Bonuses
            for (let i = bonuses.length - 1; i >= 0; i--) {
                let b = bonuses[i];
                if (dist(player, b) < b.size + PLAYER_SIZE + 30) { collectBonus(b); bonuses.splice(i, 1); }
            }
        }

        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function playSound(type) {
            if (!settings.sound) return; // Check setting first
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            osc.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            const now = audioCtx.currentTime;

            if (type === 'shoot') {
                osc.type = 'square';
                osc.frequency.setValueAtTime(400, now); osc.frequency.exponentialRampToValueAtTime(100, now + 0.1);
                gainNode.gain.setValueAtTime(0.05, now); gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(); osc.stop(now + 0.1);
            } else if (type === 'enemyShoot') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(800, now); osc.frequency.linearRampToValueAtTime(600, now + 0.1);
                gainNode.gain.setValueAtTime(0.05, now); gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(); osc.stop(now + 0.1);
            } else if (type === 'powerup') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(600, now); osc.frequency.linearRampToValueAtTime(1200, now + 0.2);
                gainNode.gain.setValueAtTime(0.1, now); gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
                osc.start(); osc.stop(now + 0.2);
            } else if (type === 'explosion') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(100, now); osc.frequency.exponentialRampToValueAtTime(0.01, now + 0.3);
                gainNode.gain.setValueAtTime(0.1, now); gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
                osc.start(); osc.stop(now + 0.3);
            } else if (type === 'laser') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(100, now); osc.frequency.linearRampToValueAtTime(50, now + 3);
                gainNode.gain.setValueAtTime(0.2, now); gainNode.gain.linearRampToValueAtTime(0, now + 3);
                osc.start(); osc.stop(now + 3);
            }
        }

        function loop() {
            if (gameState.paused) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#fff';
                ctx.font = '40px Courier New';
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillText('PAUSED', canvas.width/2, canvas.height/2);
                requestAnimationFrame(loop);
                return;
            }

            // Always clear/draw background first
            ctx.fillStyle = '#050505';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw stars even in menu (makes it look nice)
            ctx.save();
            stars.forEach(s => { s.update(); s.draw(ctx); });

            // Only update/draw game if running
            if (gameState.running && !gameState.gameOver) {
                if (shakeAmount > 0) {
                    const dx = (Math.random() - 0.5) * shakeAmount; const dy = (Math.random() - 0.5) * shakeAmount;
                    ctx.translate(dx, dy);
                    shakeAmount *= 0.9; if (shakeAmount < 0.5) shakeAmount = 0;
                }
                
                bonuses.forEach(b => { b.update(); b.draw(ctx); }); bonuses = bonuses.filter(b => b.life > 0);
                
                player.update(); player.draw(ctx);
                
                bullets.forEach(b => { b.update(); b.draw(ctx); }); bullets = bullets.filter(b => b.life > 0);
                
                asteroids.forEach(a => { a.update(player); a.draw(ctx); });
                ufos.forEach(u => { u.update(player); u.draw(ctx); });
                worms.forEach(w => { w.update(player); w.draw(ctx); });
                blackHoles.forEach(bh => { bh.update(player); bh.draw(ctx); });
                
                mines.forEach(m => { m.update(player); m.draw(ctx); });
                aegises.forEach(a => { a.update(player); a.draw(ctx); });
                hives.forEach(h => { h.update(player); h.draw(ctx); });
                drones.forEach(d => { d.update(player); d.draw(ctx); });
                lancers.forEach(l => { l.update(player); l.draw(ctx); });
                tethers.forEach(t => { t.update(); t.draw(ctx); });
                
                tornados.forEach(e => { e.update(player); e.draw(ctx); });
                reflectors.forEach(e => { e.update(); e.draw(ctx); });
                trailblazers.forEach(e => { e.update(); e.draw(ctx); });
                orbitals.forEach(e => { e.update(player); e.draw(ctx); });
                prisms.forEach(e => { e.update(); e.draw(ctx); });
                repulsors.forEach(e => { e.update(); e.draw(ctx); });

                // World 4
                // Web lines
                if (webNodes.length > 0) {
                    const byId = new Map();
                    for (let i = 0; i < webNodes.length; i++) byId.set(webNodes[i].id, webNodes[i]);
                    ctx.save();
                    ctx.strokeStyle = 'rgba(0,255,255,0.35)';
                    ctx.lineWidth = 2;
                    for (let i = 0; i < webNodes.length; i++) {
                        const n = webNodes[i];
                        if (n.prevId != null) {
                            const p = byId.get(n.prevId);
                            if (!p) continue;
                            ctx.beginPath(); ctx.moveTo(n.x, n.y); ctx.lineTo(p.x, p.y); ctx.stroke();
                        }
                    }
                    ctx.restore();
                }
                webNodes.forEach(n => { n.draw(ctx); });
                staticBeetles.forEach(e => { e.update(player); e.draw(ctx); });
                phaseMantises.forEach(e => { e.update(player); e.draw(ctx); });
                sniperMosquitos.forEach(e => { e.update(player); e.draw(ctx); });
                clusterRoaches.forEach(e => { e.update(player); e.draw(ctx); });
                roachMites.forEach(e => { e.update(player); e.draw(ctx); });
                siphonFlies.forEach(e => { e.update(player); e.draw(ctx); });
                webWeavers.forEach(e => { e.update(player); e.draw(ctx); });
                hawkShooters.forEach(e => { e.update(player); e.draw(ctx); });
                
                bossWorms.forEach(b => { b.update(player); b.draw(ctx); });
                bossLancers.forEach(b => { b.update(player); b.draw(ctx); });
                bossOrbitals.forEach(b => { b.update(player); b.draw(ctx); }); // Draw new boss

                mineShrapnels.forEach(s => { s.update(); s.draw(ctx); }); mineShrapnels = mineShrapnels.filter(s => s.hp > 0);

                particles.forEach(p => { p.update(); p.draw(ctx); }); particles = particles.filter(p => p.life > 0);
                
                // Boss Lancer Level Armor Drop
                if (gameState.wave === 22) {
                    bossArmorTimer++;
                    const armor_drop_interval = 700;
                    if (bossArmorTimer > armor_drop_interval) { 
                        bossArmorTimer = 0;
                        const bx = Math.random() * (canvas.width - 100) + 50; const by = Math.random() * (canvas.height - 100) + 50;
                        bonuses.push(new Bonus(bx, by, 2)); 
                    }
                }
                
                // Gravity logic
                let totalGx = 0; let totalGy = 0; let maxForceMag = 0; let inGravityWell = false;
                blackHoles.forEach(bh => {
                    const dx = bh.x - player.x; const dy = bh.y - player.y; const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < bh.pullRadius) {
                        inGravityWell = true;
                        const forceMag = (1 - dist/bh.pullRadius) * bh.pullForce;
                        if (forceMag > maxForceMag) maxForceMag = forceMag;
                        totalGx += (dx/dist) * forceMag; totalGy += (dy/dist) * forceMag;
                        if (dist < bh.pullRadius * 0.8) {
                            const drain = 0.166;
                            if (player.armor > 0) { player.armor -= drain; if (player.armor < 0) { player.health += player.armor; player.armor = 0; } } else { player.health -= drain; }
                            if (player.health < 0) player.health = 0;
                            updateHealthUI();
                            if (player.health <= 0) handleDeath();
                        }
                    }
                });
                repulsors.forEach(r => {
                    const dx = player.x - r.x; const dy = player.y - r.y; const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < r.pushRadius) {
                        inGravityWell = true; const forceMag = (1 - dist/r.pushRadius) * r.pushForce;
                        totalGx += (dx/dist) * forceMag; totalGy += (dy/dist) * forceMag;
                    }
                    bullets.forEach(b => {
                        const bdx = b.x - r.x; const bdy = b.y - r.y; const bd = Math.sqrt(bdx*bdx + bdy*bdy);
                        if (bd < r.pushRadius) {
                            const bf = (1 - bd/r.pushRadius) * r.pushForce * 2;
                            b.x += (bdx/bd) * bf; b.y += (bdy/bd) * bf;
                        }
                    });
                });
                if (inGravityWell) {
                    const totalMag = Math.sqrt(totalGx*totalGx + totalGy*totalGy);
                    if (totalMag > 0) { player.vx += totalGx; player.vy += totalGy; }
                }
                
                checkCollisions();
            }
            
            ctx.restore();
            requestAnimationFrame(loop);
        }
        init();
    </script>
</body>
</html>
